**User**

너 사고루틴(Thinking Routines)에 대해 알고 있니?

---

**Cursor**

네, 사고루틴(Thinking Routines)에 대해 알고 있습니다! 

사고루틴은 하버드 대학교의 Project Zero에서 개발된 교육 방법론으로, 학생들의 깊이 있는 사고를 촉진하기 위한 구조화된 사고 도구들입니다. 이 루틴들은 다음과 같은 특징을 가지고 있습니다:

## 주요 특징:
- **구조화된 사고**: 복잡한 사고 과정을 단계별로 나누어 접근
- **가시적 사고**: 학생들의 사고 과정을 명시적으로 드러내게 함
- **반복 가능**: 다양한 상황과 주제에 적용 가능한 패턴

## 대표적인 사고루틴들:

### 1. **See-Think-Wonder (보기-생각하기-궁금해하기)**
- 보기: 무엇을 보고 있는가?
- 생각하기: 무엇을 생각하는가?
- 궁금해하기: 무엇이 궁금한가?

### 2. **Think-Pair-Share (생각-짝-공유)**
- 개별적으로 생각하고, 짝과 논의한 후, 전체와 공유

### 3. **What Makes You Say That? (무엇이 그렇게 말하게 하는가?)**
- 주장과 근거를 명확히 구분하여 생각하게 함

### 4. **Circle of Viewpoints (관점의 원)**
- 다양한 관점에서 상황을 바라보게 함

### 5. **I Used to Think... Now I Think... (예전에는... 지금은...)**
- 학습 전후의 생각 변화를 성찰

현재 작업 공간이 "Thinking Routines"라는 이름으로 되어 있는데, 혹시 이와 관련된 프로젝트나 자료를 작업하고 계신가요? 구체적으로 어떤 도움이 필요하신지 알려주시면 더 자세히 도와드릴 수 있습니다.

---

**User**

그럼 지금 올려주는 이 파일이 이해가 되니?

---

**Cursor**

현재 작업 공간에 어떤 파일이 있는지 확인해보겠습니다.

아, PDF 파일이 있네요! 이 파일은 "개념기반 탐구 학습 단계와 사고루틴(Thinking Routines)의 연계적 적용 방안 탐색"에 관한 학술 자료인 것 같습니다.

죄송하지만 현재 제가 사용할 수 있는 도구로는 PDF 파일의 내용을 직접 읽을 수 없습니다. PDF 파일의 내용을 이해하려면:

1. **텍스트로 변환**: PDF 내용을 텍스트 파일로 변환해서 공유해주시거나
2. **주요 내용 요약**: 파일의 핵심 내용이나 특정 부분을 텍스트로 복사해서 보여주시면
3. **이미지 캡처**: 특정 페이지나 다이어그램을 이미지로 공유해주시면

더 구체적으로 도움을 드릴 수 있을 것 같습니다.

이 논문이 개념기반 학습과 사고루틴의 연계에 관한 내용이라면, 아마도 다음과 같은 주제들을 다루고 있을 것으로 예상됩니다:
- 개념기반 탐구학습의 단계별 접근
- 각 단계에서 활용할 수 있는 적절한 사고루틴들
- 실제 교육 현장에서의 적용 사례나 방안

어떤 부분에 대해 특히 궁금하신가요?

---

**User**

텍스트 파일로 변환했는데

---

**Cursor**

좋습니다! 텍스트 파일로 변환해주셨네요. 이제 내용을 읽어보겠습니다.

완벽합니다! 이제 이 논문의 내용을 완전히 이해할 수 있습니다. 

이 논문은 **개념기반 탐구 학습과 사고루틴(Thinking Routines)의 연계적 적용**에 관한 매우 체계적이고 실질적인 연구입니다. 주요 내용을 정리해드리면:

## 🎯 연구 목적
2022 개정 교육과정과 IB 프로그램이 강조하는 **개념기반 탐구 학습**의 각 단계에서 학생들의 **깊이 있는 사고를 지원하는 사고루틴**을 효과적으로 연계하여 적용하는 방안을 탐색

## 📊 연구 방법
- **107개의 사고루틴** 수집 및 분석
- **Marschall & French(2018)의 개념기반 탐구 학습 모형** 기반
- 4인 연구팀의 개별·집단 분석을 통한 연계 틀 구성

## 🔍 개념기반 탐구 학습 단계
1. **관계맺기(Engage)** - 사전지식 활성화, 동기유발
2. **집중하기(Focus)** - 개념 정립, 오개념 수정  
3. **탐구하기(Investigate)** - 체계적 조사활동
4. **조직 및 정리하기(Organize)** - 결과 구조화
5. **일반화하기(Generalize)** - 개념 간 관계 도출
6. **전이하기(Transfer)** - 새로운 맥락 적용
7. **성찰하기(Reflect)** - 메타인지 활동

## 💡 주요 연구 결과

### 1. 단계별 사고루틴 분포
- **관계맺기(35개)**와 **탐구하기(34개)** 단계에 가장 많은 사고루틴 연계
- 전체 107개 중 64.49% 차지
- 모든 단계에서 충분한 선택지 제공

### 2. 핵심 사고루틴 예시
- **상호작용**: `Give One Get One`, `SAIL`
- **관계맺기**: `4C(Connect-Challenge-Concepts-Changes)`, `See-Think-Wonder`
- **집중하기**: `Lenses`, `Hotspots`
- **탐구하기**: `Red Light Yellow Light`, `Circle of Viewpoints`
- **조직정리**: `Generate-Sort-Connect-Elaborate`, `Microlab Protocol`
- **일반화**: `Claim Support Question`, `Headlines`
- **전이하기**: `Circles of Action`, `Tug of War`
- **성찰하기**: `ESP+I`, `Connect-Extend-Challenge`

### 3. 사고루틴의 특징
- **구조화된 질문 모음**으로 사고 과정 가시화
- **반복 사용**을 통한 교실 문화 형성
- **메타인지 발달** 및 **개념적 이해** 촉진

## 🎓 교육적 의의

1. **2022 개정 교육과정**의 핵심 아이디어 중심 학습 지원
2. **IB 교육철학**과의 연계성 확보
3. **교사의 실천적 도구** 제공
4. **학생의 고차원적 사고력** 개발

## 💭 제언사항

1. **유연한 접근** - 상황에 맞는 선택적 활용
2. **교사 전문성 강화** - 체계적 연수 프로그램 필요
3. **효과성 검증** - 데이터 축적 및 분석
4. **한국형 사고루틴** 개발
5. **AI 기술 도입** - 사고 과정 시뮬레이션

이 연구는 단순히 이론적 탐구에 그치지 않고, **실제 교육현장에서 바로 활용할 수 있는 구체적인 가이드라인**을 제시한다는 점에서 매우 실용적이고 가치있는 연구라고 생각됩니다! 

특히 각 단계별로 어떤 사고루틴을 어떻게 활용할지에 대한 **구체적인 예시와 절차**까지 제시하고 있어서 교사들이 실제로 적용하기에 매우 유용할 것 같습니다.

---

**User**

나는 이 중에서 교사들이 많이 사용하고 있는 몇 가지 사고루틴을 웹앱 형태로 만들어서 학생들이 사고루틴의 과정으로 만든 결과물을 피드백하고 분석하는 기능을 제공하고 싶어

---

**Cursor**

정말 훌륭한 아이디어입니다! 교사들이 많이 사용하는 사고루틴을 웹앱으로 만들어 학생들의 사고 과정을 분석하고 피드백하는 시스템을 구축하는 것은 매우 실용적이고 혁신적인 접근이라고 생각합니다.

논문에서 제시된 내용을 바탕으로 **가장 활용도가 높고 구현하기 적합한 사고루틴들**을 추천해드리겠습니다:

## 🎯 우선 구현 추천 사고루틴

### 1. **핵심 사고루틴 (Core Thinking Routines)**
- **See-Think-Wonder** - 가장 기본적이고 널리 사용됨
- **Think-Pair-Share** - 협력학습에 최적화
- **What Makes You Say That?** - 근거 기반 사고 훈련
- **Connect-Extend-Challenge** - 성찰 및 확장 사고

### 2. **단계별 핵심 사고루틴**
- **관계맺기**: `4C (Connect-Challenge-Concepts-Changes)`
- **탐구하기**: `Claim-Support-Question`
- **일반화**: `3-2-1 Bridge`
- **성찰하기**: `I Used to Think... Now I Think...`

## 💻 웹앱 구현 제안

### 📱 **기본 구조**
```
사고루틴 웹앱
├── 사고루틴 선택 메뉴
├── 단계별 입력 인터페이스
├── 실시간 피드백 시스템
├── 결과 분석 대시보드
└── 교사용 관리 패널
```

### 🔧 **주요 기능**

#### 1. **학생용 기능**
- **단계별 가이드**: 각 사고루틴의 절차를 단계별로 안내
- **입력 인터페이스**: 텍스트, 이미지, 음성 입력 지원
- **실시간 힌트**: 각 단계에서 도움말 제공
- **진행 상황 저장**: 중간 저장 및 이어서 작업 기능

#### 2. **AI 피드백 시스템**
- **사고 깊이 분석**: 응답의 구체성, 논리성 평가
- **개념 연결 분석**: 학습 내용과의 연관성 확인
- **질문 품질 평가**: 궁금증의 창의성과 탐구 가능성 분석
- **성장 추적**: 이전 결과와 비교하여 발전 정도 측정

#### 3. **교사용 관리 기능**
- **학급 관리**: 학생별 진행 상황 모니터링
- **결과 분석**: 개인별/학급별 사고 패턴 분석
- **피드백 커스터마이징**: 교사 개인화 피드백 추가
- **학습 데이터 내보내기**: 포트폴리오 생성 지원

### 🎨 **UI/UX 설계 방향**

#### **See-Think-Wonder 예시**
```
📷 [이미지 업로드 영역]
   "관찰하고 싶은 자료를 업로드하세요"

👀 SEE (관찰하기)
   [텍스트 입력창]
   "무엇을 보았나요? 구체적으로 적어보세요"
   💡 힌트: 색깔, 모양, 크기, 위치 등을 자세히 관찰해보세요

🤔 THINK (생각하기)  
   [텍스트 입력창]
   "관찰한 것을 바탕으로 어떤 생각이 드나요?"
   💡 힌트: 왜 그럴까요? 어떤 의미일까요?

❓ WONDER (궁금해하기)
   [텍스트 입력창]  
   "어떤 점이 궁금한가요?"
   💡 힌트: 더 알고 싶은 것은 무엇인가요?

[AI 피드백 보기] [저장하기] [공유하기]
```

### 🤖 **AI 분석 기능**

#### **분석 항목**
1. **사고의 깊이**
   - 표면적 관찰 vs 심층적 분석
   - 구체성과 상세함 정도
   
2. **논리적 연결성**
   - 관찰-생각-질문 간의 연결고리
   - 근거 기반 추론 능력

3. **창의성과 독창성**
   - 다양한 관점 제시
   - 참신한 질문 생성

4. **개념적 이해**
   - 학습 내용과의 연관성
   - 전이 가능성

#### **피드백 예시**
```
🎯 분석 결과

✅ 잘한 점:
- 색깔과 모양을 구체적으로 관찰했어요
- 관찰한 내용을 바탕으로 논리적으로 생각했어요

🚀 더 발전시킬 점:
- 다른 관점에서도 생각해보면 어떨까요?
- 궁금한 점을 더 구체적으로 표현해보세요

💡 제안:
- "왜 이런 색을 사용했을까?"라는 질문을 
  "작가가 이 색을 선택한 이유는 무엇일까?"로 
  더 구체화해보세요
```

### 📊 **데이터 활용 방안**

#### **개인 성장 추적**
- 사고 깊이의 변화 그래프
- 자주 사용하는 사고 패턴 분석
- 강점과 개선점 시각화

#### **학급 전체 분석**
- 학급별 사고 패턴 비교
- 협력학습 효과 분석
- 개념 이해도 분포

### 🛠 **기술 스택 제안**

#### **프론트엔드**
- React/Vue.js - 반응형 UI
- Chart.js - 데이터 시각화
- Socket.io - 실시간 협업

#### **백엔드**
- Node.js/Python - 서버 개발
- OpenAI API - AI 분석 기능
- MongoDB - 유연한 데이터 저장

#### **AI 분석**
- 자연어 처리 (NLP) - 텍스트 분석
- 감정 분석 - 학습 동기 파악
- 키워드 추출 - 개념 연결 분석

## 🚀 **단계별 개발 계획**

### **1단계: MVP 개발**
- See-Think-Wonder 구현
- 기본 피드백 시스템
- 개인 결과 저장

### **2단계: 기능 확장**
- 3-4개 사고루틴 추가
- AI 피드백 고도화
- 교사용 대시보드

### **3단계: 고도화**
- 협력학습 기능
- 상세 분석 리포트
- 학습 포트폴리오

이런 웹앱을 개발하시면 **사고루틴의 디지털 전환**을 통해 더 많은 교사와 학생들이 체계적으로 사고력을 기를 수 있을 것 같습니다! 

구체적으로 어떤 사고루틴부터 시작하고 싶으신지, 또는 특별히 중점을 두고 싶은 기능이 있으신지 알려주시면 더 자세한 설계를 도와드릴 수 있습니다! 🎯

```plaintext
사고루틴 웹앱
├── 사고루틴 선택 메뉴
├── 단계별 입력 인터페이스
├── 실시간 피드백 시스템
├── 결과 분석 대시보드
└── 교사용 관리 패널
```

```plaintext
📷 [이미지 업로드 영역]
   "관찰하고 싶은 자료를 업로드하세요"

👀 SEE (관찰하기)
   [텍스트 입력창]
   "무엇을 보았나요? 구체적으로 적어보세요"
   💡 힌트: 색깔, 모양, 크기, 위치 등을 자세히 관찰해보세요

🤔 THINK (생각하기)  
   [텍스트 입력창]
   "관찰한 것을 바탕으로 어떤 생각이 드나요?"
   💡 힌트: 왜 그럴까요? 어떤 의미일까요?

❓ WONDER (궁금해하기)
   [텍스트 입력창]  
   "어떤 점이 궁금한가요?"
   💡 힌트: 더 알고 싶은 것은 무엇인가요?

[AI 피드백 보기] [저장하기] [공유하기]
```

```plaintext
🎯 분석 결과

✅ 잘한 점:
- 색깔과 모양을 구체적으로 관찰했어요
- 관찰한 내용을 바탕으로 논리적으로 생각했어요

🚀 더 발전시킬 점:
- 다른 관점에서도 생각해보면 어떨까요?
- 궁금한 점을 더 구체적으로 표현해보세요

💡 제안:
- "왜 이런 색을 사용했을까?"라는 질문을 
  "작가가 이 색을 선택한 이유는 무엇일까?"로 
  더 구체화해보세요
```

---

**User**

우선 가장 많이 사용하는 See-Think-Wonder 하나만 만들어서 MVP로 테스트를 해보자 내가 생각하는 전체적인 웹앱의 구동 순서를 알려줄게

1. 사이트에 접속하면 교사는 자신의 계정으로 로그인한다
2. 대시보드에서 학생들에게 배포할 활동방을 만든다.(이 때 학생들이 6자리의 코드를 입력해서 교사가 배포한 활동방에 참여할 수 있도록 한다.)
3. 활동방에서는 교사가 사고루틴을 선택하고 선택한 사고루틴의 양식에 맞게 내용을 입력한다.(이미지, 질문 등 사고루틴의 양식에 맞춰서)
4. 배포를 하면 학생들은 활동방에 할당된 6개의 코드를 입력해서 교사가 배포한 사고루틴을 실시한다.(학생들은 별도의 사이트 주소로 접속해서 코드만 입력하면 바로 참여할 수 있도록 하면 좋겠음)
5. 학생들의 사고루틴이 완료되었으면 교사는 2번에서 만든 활동방에 가서 학생들의 사고루틴 산출물을 확인할 수 있음.
6. 산출물에 대해 생성형 AI의 도움을 받아 분석 및 피드백을 제공함(** 이 단계가 핵심인데, 각 사고루틴에서 가장 목표하고 있는 내용들을 생성형 AI가 제대로 이해하고 있어야 분석 및 피드백에 의미가 있음) 그래서 가능하다면 생성형 AI에게 시스템 프롬포팅이나 각 사고루틴의 자세한 설명이 있는 문서를 RAG로 연결하고 싶음
7. 생성형 AI가 분석하고 피드백한 내용에 교사의 전문적인 내용을 더해서 평가를 완료하고 저장함.

---

**Cursor**

정말 체계적이고 실용적인 워크플로우네요! 특히 6자리 코드를 통한 간편한 참여 방식과 RAG를 활용한 AI 피드백 시스템이 매우 인상적입니다. See-Think-Wonder MVP 개발을 위한 상세한 구현 방안을 제시해드리겠습니다.

## 🏗️ 시스템 아키텍처

### 📱 **사이트 구조**
```
메인 도메인: thinking-routines.com
├── 교사용: thinking-routines.com/teacher
└── 학생용: thinking-routines.com/student
```

### 🔧 **기술 스택**
```
Frontend: React + Tailwind CSS
Backend: Node.js + Express
Database: MongoDB
AI: OpenAI GPT-4 + RAG (Pinecone/Weaviate)
Authentication: JWT
Real-time: Socket.io
```

## 🎯 **단계별 구현 상세**

### **1단계: 교사 로그인 시스템**

#### **로그인 페이지 (/teacher)**
```jsx
// 교사 로그인 UI
<div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100">
  <div className="flex items-center justify-center min-h-screen">
    <div className="bg-white p-8 rounded-lg shadow-lg w-96">
      <h1 className="text-2xl font-bold text-center mb-6">
        사고루틴 교사 로그인
      </h1>
      <form>
        <input 
          type="email" 
          placeholder="이메일" 
          className="w-full p-3 border rounded-lg mb-4"
        />
        <input 
          type="password" 
          placeholder="비밀번호" 
          className="w-full p-3 border rounded-lg mb-6"
        />
        <button className="w-full bg-blue-600 text-white p-3 rounded-lg">
          로그인
        </button>
      </form>
    </div>
  </div>
</div>
```

### **2단계: 활동방 생성 시스템**

#### **교사 대시보드**
```jsx
// 대시보드 메인 화면
<div className="p-6">
  <div className="flex justify-between items-center mb-6">
    <h1 className="text-3xl font-bold">내 활동방</h1>
    <button 
      onClick={createNewRoom}
      className="bg-green-600 text-white px-6 py-3 rounded-lg"
    >
      + 새 활동방 만들기
    </button>
  </div>
  
  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
    {rooms.map(room => (
      <div key={room.id} className="bg-white p-6 rounded-lg shadow-lg">
        <h3 className="text-xl font-semibold mb-2">{room.title}</h3>
        <p className="text-gray-600 mb-4">{room.description}</p>
        <div className="flex justify-between items-center">
          <span className="text-2xl font-bold text-blue-600">
            {room.code}
          </span>
          <div className="flex space-x-2">
            <button className="bg-blue-500 text-white px-4 py-2 rounded">
              편집
            </button>
            <button className="bg-gray-500 text-white px-4 py-2 rounded">
              결과보기
            </button>
          </div>
        </div>
      </div>
    ))}
  </div>
</div>
```

#### **6자리 코드 생성 로직**
```javascript
// 활동방 코드 생성 함수
function generateRoomCode() {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for (let i = 0; i < 6; i++) {
    code += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return code;
}

// 중복 검사 및 생성
async function createUniqueRoomCode() {
  let code;
  let isUnique = false;
  
  while (!isUnique) {
    code = generateRoomCode();
    const existingRoom = await Room.findOne({ code });
    if (!existingRoom) {
      isUnique = true;
    }
  }
  
  return code;
}
```

### **3단계: See-Think-Wonder 활동 설정**

#### **사고루틴 설정 인터페이스**
```jsx
// See-Think-Wonder 설정 화면
<div className="max-w-4xl mx-auto p-6">
  <h2 className="text-2xl font-bold mb-6">See-Think-Wonder 활동 설정</h2>
  
  <div className="bg-white rounded-lg shadow-lg p-6">
    <div className="mb-6">
      <label className="block text-sm font-medium mb-2">활동 제목</label>
      <input 
        type="text" 
        placeholder="예: 고흐의 별이 빛나는 밤 감상하기"
        className="w-full p-3 border rounded-lg"
      />
    </div>
    
    <div className="mb-6">
      <label className="block text-sm font-medium mb-2">관찰 자료 업로드</label>
      <div className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center">
        <input type="file" accept="image/*" className="hidden" id="image-upload" />
        <label htmlFor="image-upload" className="cursor-pointer">
          <div className="text-gray-500">
            <svg className="mx-auto h-12 w-12 mb-4" fill="none" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} 
                    d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
            </svg>
            <p>이미지를 클릭하여 업로드하세요</p>
          </div>
        </label>
      </div>
    </div>
    
    <div className="mb-6">
      <label className="block text-sm font-medium mb-2">추가 안내 사항</label>
      <textarea 
        placeholder="학생들에게 전달할 추가 안내사항을 입력하세요"
        className="w-full p-3 border rounded-lg h-24"
      />
    </div>
    
    <div className="flex justify-end space-x-4">
      <button className="bg-gray-500 text-white px-6 py-3 rounded-lg">
        저장
      </button>
      <button className="bg-blue-600 text-white px-6 py-3 rounded-lg">
        학생들에게 배포
      </button>
    </div>
  </div>
</div>
```

### **4단계: 학생 참여 시스템**

#### **학생용 입장 페이지 (/student)**
```jsx
// 학생 참여 화면
<div className="min-h-screen bg-gradient-to-br from-purple-50 to-pink-100">
  <div className="flex items-center justify-center min-h-screen">
    <div className="bg-white p-8 rounded-lg shadow-lg w-96">
      <h1 className="text-2xl font-bold text-center mb-6">
        사고루틴 참여하기
      </h1>
      <div className="mb-4">
        <label className="block text-sm font-medium mb-2">활동 코드 입력</label>
        <input 
          type="text" 
          placeholder="6자리 코드 입력"
          maxLength="6"
          className="w-full p-3 border rounded-lg text-center text-2xl font-bold tracking-widest"
          onChange={handleCodeInput}
        />
      </div>
      <div className="mb-6">
        <label className="block text-sm font-medium mb-2">이름</label>
        <input 
          type="text" 
          placeholder="이름을 입력하세요"
          className="w-full p-3 border rounded-lg"
        />
      </div>
      <button 
        onClick={joinActivity}
        className="w-full bg-purple-600 text-white p-3 rounded-lg"
      >
        활동 참여하기
      </button>
    </div>
  </div>
</div>
```

#### **See-Think-Wonder 학생 인터페이스**
```jsx
// 학생용 사고루틴 실행 화면
<div className="max-w-4xl mx-auto p-6">
  <div className="bg-white rounded-lg shadow-lg">
    {/* 헤더 */}
    <div className="bg-blue-600 text-white p-4 rounded-t-lg">
      <h1 className="text-xl font-bold">See-Think-Wonder</h1>
      <p className="text-blue-100">차근차근 따라해보세요!</p>
    </div>
    
    {/* 관찰 자료 */}
    <div className="p-6 border-b">
      <img src={activityData.image} alt="관찰 자료" className="w-full max-w-2xl mx-auto rounded-lg" />
    </div>
    
    {/* 단계별 입력 */}
    <div className="p-6 space-y-8">
      {/* SEE 단계 */}
      <div className="border-l-4 border-green-500 pl-6">
        <h3 className="text-lg font-bold text-green-700 mb-2">
          👀 SEE (관찰하기)
        </h3>
        <p className="text-gray-600 mb-4">
          무엇을 보았나요? 구체적으로 관찰한 내용을 적어보세요.
        </p>
        <textarea 
          placeholder="색깔, 모양, 크기, 위치 등을 자세히 관찰해보세요..."
          className="w-full p-4 border rounded-lg h-32"
          value={responses.see}
          onChange={(e) => updateResponse('see', e.target.value)}
        />
        <div className="text-sm text-gray-500 mt-2">
          💡 힌트: 첫 번째 느낌보다는 자세히 들여다보세요!
        </div>
      </div>
      
      {/* THINK 단계 */}
      <div className="border-l-4 border-blue-500 pl-6">
        <h3 className="text-lg font-bold text-blue-700 mb-2">
          🤔 THINK (생각하기)
        </h3>
        <p className="text-gray-600 mb-4">
          관찰한 것을 바탕으로 어떤 생각이 드나요?
        </p>
        <textarea 
          placeholder="왜 그럴까요? 어떤 의미일까요? 어떤 느낌이 드나요?"
          className="w-full p-4 border rounded-lg h-32"
          value={responses.think}
          onChange={(e) => updateResponse('think', e.target.value)}
        />
        <div className="text-sm text-gray-500 mt-2">
          💡 힌트: 관찰한 내용과 연결지어 생각해보세요!
        </div>
      </div>
      
      {/* WONDER 단계 */}
      <div className="border-l-4 border-purple-500 pl-6">
        <h3 className="text-lg font-bold text-purple-700 mb-2">
          ❓ WONDER (궁금해하기)
        </h3>
        <p className="text-gray-600 mb-4">
          어떤 점이 궁금한가요? 더 알고 싶은 것은 무엇인가요?
        </p>
        <textarea 
          placeholder="궁금한 점들을 자유롭게 적어보세요..."
          className="w-full p-4 border rounded-lg h-32"
          value={responses.wonder}
          onChange={(e) => updateResponse('wonder', e.target.value)}
        />
        <div className="text-sm text-gray-500 mt-2">
          💡 힌트: 더 탐구하고 싶은 질문을 만들어보세요!
        </div>
      </div>
    </div>
    
    {/* 제출 버튼 */}
    <div className="p-6 bg-gray-50 rounded-b-lg">
      <button 
        onClick={submitResponse}
        className="w-full bg-green-600 text-white p-4 rounded-lg font-bold"
        disabled={!isComplete}
      >
        완료하기
      </button>
    </div>
  </div>
</div>
```

### **5단계: 결과 확인 시스템**

#### **교사용 결과 대시보드**
```jsx
// 학생 결과 확인 화면
<div className="max-w-6xl mx-auto p-6">
  <div className="flex justify-between items-center mb-6">
    <h1 className="text-2xl font-bold">학생 응답 결과</h1>
    <div className="flex space-x-4">
      <button className="bg-blue-600 text-white px-4 py-2 rounded-lg">
        전체 AI 분석
      </button>
      <button className="bg-green-600 text-white px-4 py-2 rounded-lg">
        결과 내보내기
      </button>
    </div>
  </div>
  
  <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
    {studentResponses.map(response => (
      <div key={response.id} className="bg-white rounded-lg shadow-lg p-6">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-lg font-semibold">{response.studentName}</h3>
          <span className="text-sm text-gray-500">
            {formatTime(response.submittedAt)}
          </span>
        </div>
        
        <div className="space-y-4">
          <div className="border-l-4 border-green-500 pl-4">
            <h4 className="font-medium text-green-700">SEE</h4>
            <p className="text-gray-700">{response.see}</p>
          </div>
          
          <div className="border-l-4 border-blue-500 pl-4">
            <h4 className="font-medium text-blue-700">THINK</h4>
            <p className="text-gray-700">{response.think}</p>
          </div>
          
          <div className="border-l-4 border-purple-500 pl-4">
            <h4 className="font-medium text-purple-700">WONDER</h4>
            <p className="text-gray-700">{response.wonder}</p>
          </div>
        </div>
        
        <div className="mt-4 pt-4 border-t">
          <button 
            onClick={() => analyzeResponse(response.id)}
            className="bg-orange-500 text-white px-4 py-2 rounded-lg mr-2"
          >
            AI 분석하기
          </button>
          <button 
            onClick={() => addTeacherFeedback(response.id)}
            className="bg-gray-600 text-white px-4 py-2 rounded-lg"
          >
            교사 피드백 추가
          </button>
        </div>
      </div>
    ))}
  </div>
</div>
```

### **6단계: RAG 기반 AI 분석 시스템**

#### **See-Think-Wonder 전용 시스템 프롬프트**
```javascript
// RAG 문서 준비
const seeThinkWonderGuide = `
See-Think-Wonder 사고루틴 분석 가이드

## 목적
- 신중한 관찰 능력 개발
- 해석적 사고력 향상
- 탐구 정신 함양
- 호기심 기반 학습 촉진

## 각 단계별 평가 기준

### SEE (관찰하기)
평가 요소:
- 구체성: 세부 사항을 얼마나 자세히 관찰했는가?
- 객관성: 개인적 해석보다 사실적 관찰에 집중했는가?
- 다양성: 다양한 관점에서 관찰했는가?
- 정확성: 실제 보이는 것을 정확히 기술했는가?

우수 사례:
- "왼쪽 상단에 노란색 별들이 소용돌이 모양으로 배치되어 있다"
- "건물들은 어둡고 각진 모양이며, 창문에서 노란 빛이 새어나온다"

개선 필요 사례:
- "예쁘다", "멋있다" (감정적 표현)
- "별이 있다" (너무 단순한 관찰)

### THINK (생각하기)
평가 요소:
- 연결성: 관찰한 내용과 논리적으로 연결되었는가?
- 깊이: 표면적 생각을 넘어 깊이 있게 사고했는가?
- 추론: 관찰을 바탕으로 합리적 추론을 했는가?
- 창의성: 독창적이고 다양한 관점을 제시했는가?

우수 사례:
- "소용돌이치는 별들이 역동적인 느낌을 주어 화가의 감정 상태를 표현하는 것 같다"
- "어두운 마을과 밝은 하늘의 대비가 현실과 꿈의 경계를 나타내는 것 같다"

### WONDER (궁금해하기)
평가 요소:
- 탐구 가능성: 실제로 탐구할 수 있는 질문인가?
- 구체성: 구체적이고 명확한 질문인가?
- 확장성: 더 깊은 학습으로 이어질 수 있는가?
- 창의성: 참신하고 흥미로운 질문인가?

우수 사례:
- "왜 고흐는 밤하늘을 소용돌이 모양으로 그렸을까?"
- "이 그림을 그릴 때 고흐의 심리 상태는 어땠을까?"
- "실제 밤하늘과 다르게 표현한 이유는 무엇일까?"

## 종합 평가 기준
1. 사고의 흐름: SEE → THINK → WONDER의 논리적 연결
2. 사고의 깊이: 단계별 사고의 심화 정도
3. 창의성: 독창적이고 참신한 관점
4. 탐구 정신: 지속적인 학습 의욕 표현
`;

// AI 분석 함수
async function analyzeSTWResponse(response) {
  const prompt = `
다음은 학생이 See-Think-Wonder 사고루틴으로 작성한 응답입니다.
위의 가이드라인을 참고하여 분석해주세요.

학생 응답:
SEE: ${response.see}
THINK: ${response.think}
WONDER: ${response.wonder}

다음 형식으로 분석해주세요:

## 전체 평가
- 사고의 흐름: [SEE-THINK-WONDER 연결성 평가]
- 사고의 깊이: [각 단계별 깊이 평가]
- 종합 점수: [5점 만점]

## 단계별 분석
### SEE (관찰하기)
- 잘한 점: 
- 개선점: 
- 점수: [5점 만점]

### THINK (생각하기)
- 잘한 점:
- 개선점:
- 점수: [5점 만점]

### WONDER (궁금해하기)
- 잘한 점:
- 개선점:
- 점수: [5점 만점]

## 맞춤형 피드백
- 격려 메시지:
- 구체적 개선 제안:
- 다음 단계 학습 제안:

## 교사 참고사항
- 주목할 점:
- 추가 지도 방향:
`;

  const analysis = await openai.chat.completions.create({
    model: "gpt-4",
    messages: [
      { role: "system", content: seeThinkWonderGuide },
      { role: "user", content: prompt }
    ],
    temperature: 0.7
  });

  return analysis.choices[0].message.content;
}
```

### **7단계: 교사 피드백 통합 시스템**

#### **AI 분석 + 교사 피드백 인터페이스**
```jsx
// 피드백 편집 화면
<div className="max-w-4xl mx-auto p-6">
  <div className="bg-white rounded-lg shadow-lg p-6">
    <h2 className="text-xl font-bold mb-4">AI 분석 결과 + 교사 피드백</h2>
    
    {/* AI 분석 결과 */}
    <div className="bg-blue-50 p-4 rounded-lg mb-6">
      <h3 className="font-semibold text-blue-800 mb-2">🤖 AI 분석 결과</h3>
      <div className="whitespace-pre-wrap text-sm">
        {aiAnalysis}
      </div>
    </div>
    
    {/* 교사 피드백 추가 */}
    <div className="border-t pt-6">
      <h3 className="font-semibold mb-4">👨‍🏫 교사 피드백 추가</h3>
      
      <div className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-2">개인별 격려 메시지</label>
          <textarea 
            className="w-full p-3 border rounded-lg h-20"
            placeholder="이 학생만을 위한 개인적인 격려와 칭찬을 적어주세요..."
          />
        </div>
        
        <div>
          <label className="block text-sm font-medium mb-2">구체적 개선 제안</label>
          <textarea 
            className="w-full p-3 border rounded-lg h-20"
            placeholder="다음에 더 잘할 수 있는 구체적인 방법을 제안해주세요..."
          />
        </div>
        
        <div>
          <label className="block text-sm font-medium mb-2">추천 활동</label>
          <textarea 
            className="w-full p-3 border rounded-lg h-20"
            placeholder="이 학생에게 추천하고 싶은 후속 활동이나 자료를 제안해주세요..."
          />
        </div>
      </div>
      
      <div className="flex justify-end mt-6 space-x-4">
        <button className="bg-gray-500 text-white px-6 py-2 rounded-lg">
          임시저장
        </button>
        <button className="bg-green-600 text-white px-6 py-2 rounded-lg">
          피드백 완료
        </button>
      </div>
    </div>
  </div>
</div>
```

## 📊 **데이터베이스 스키마**

```javascript
// MongoDB 스키마 설계
const RoomSchema = new mongoose.Schema({
  code: { type: String, unique: true, required: true },
  title: String,
  description: String,
  teacherId: { type: mongoose.Schema.Types.ObjectId, ref: 'Teacher' },
  thinkingRoutine: {
    type: String,
    enum: ['see-think-wonder'],
    required: true
  },
  content: {
    image: String,
    instructions: String,
    additionalNotes: String
  },
  isActive: { type: Boolean, default: true },
  createdAt: { type: Date, default: Date.now },
  responses: [{
    studentName: String,
    see: String,
    think: String,
    wonder: String,
    submittedAt: Date,
    aiAnalysis: String,
    teacherFeedback: {
      encouragement: String,
      improvement: String,
      recommendations: String
    },
    finalScore: Number
  }]
});

const TeacherSchema = new mongoose.Schema({
  email: { type: String, unique: true },
  password: String,
  name: String,
  school: String,
  createdAt: { type: Date, default: Date.now }
});
```

## 🚀 **배포 및 테스트 계획**

### **MVP 테스트 시나리오**
1. **교사 계정 생성 및 로그인**
2. **See-Think-Wonder 활동방 생성**
3. **6자리 코드로 학생 참여**
4. **학생 응답 제출**
5. **AI 분석 및 교사 피드백**
6. **결과 저장 및 내보내기**

### **성능 최적화**
- 이미지 업로드: AWS S3 + CloudFront
- 실시간 업데이트: Socket.io
- AI 응답 캐싱: Redis
- 데이터베이스 인덱싱: MongoDB Atlas

이런 식으로 구현하시면 교사와 학생 모두에게 직관적이고 효과적인 사고루틴 플랫폼을 제공할 수 있을 것 같습니다! 

특히 RAG 기반 AI 분석 시스템이 핵심이 될 것 같은데, 혹시 특정 부분에 대해 더 자세한 구현 방법이 필요하시거나 다른 질문이 있으시면 언제든 말씀해주세요! 🎯

```plaintext
메인 도메인: thinking-routines.com
├── 교사용: thinking-routines.com/teacher
└── 학생용: thinking-routines.com/student
```

```plaintext
Frontend: React + Tailwind CSS
Backend: Node.js + Express
Database: MongoDB
AI: OpenAI GPT-4 + RAG (Pinecone/Weaviate)
Authentication: JWT
Real-time: Socket.io
```

```javascriptreact
// 교사 로그인 UI
<div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100">
  <div className="flex items-center justify-center min-h-screen">
    <div className="bg-white p-8 rounded-lg shadow-lg w-96">
      <h1 className="text-2xl font-bold text-center mb-6">
        사고루틴 교사 로그인
      </h1>
      <form>
        <input 
          type="email" 
          placeholder="이메일" 
          className="w-full p-3 border rounded-lg mb-4"
        />
        <input 
          type="password" 
          placeholder="비밀번호" 
          className="w-full p-3 border rounded-lg mb-6"
        />
        <button className="w-full bg-blue-600 text-white p-3 rounded-lg">
          로그인
        </button>
      </form>
    </div>
  </div>
</div>
```

```javascriptreact
// 대시보드 메인 화면
<div className="p-6">
  <div className="flex justify-between items-center mb-6">
    <h1 className="text-3xl font-bold">내 활동방</h1>
    <button 
      onClick={createNewRoom}
      className="bg-green-600 text-white px-6 py-3 rounded-lg"
    >
      + 새 활동방 만들기
    </button>
  </div>
  
  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
    {rooms.map(room => (
      <div key={room.id} className="bg-white p-6 rounded-lg shadow-lg">
        <h3 className="text-xl font-semibold mb-2">{room.title}</h3>
        <p className="text-gray-600 mb-4">{room.description}</p>
        <div className="flex justify-between items-center">
          <span className="text-2xl font-bold text-blue-600">
            {room.code}
          </span>
          <div className="flex space-x-2">
            <button className="bg-blue-500 text-white px-4 py-2 rounded">
              편집
            </button>
            <button className="bg-gray-500 text-white px-4 py-2 rounded">
              결과보기
            </button>
          </div>
        </div>
      </div>
    ))}
  </div>
</div>
```

```javascript
// 활동방 코드 생성 함수
function generateRoomCode() {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for (let i = 0; i < 6; i++) {
    code += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return code;
}

// 중복 검사 및 생성
async function createUniqueRoomCode() {
  let code;
  let isUnique = false;
  
  while (!isUnique) {
    code = generateRoomCode();
    const existingRoom = await Room.findOne({ code });
    if (!existingRoom) {
      isUnique = true;
    }
  }
  
  return code;
}
```

```javascriptreact
// See-Think-Wonder 설정 화면
<div className="max-w-4xl mx-auto p-6">
  <h2 className="text-2xl font-bold mb-6">See-Think-Wonder 활동 설정</h2>
  
  <div className="bg-white rounded-lg shadow-lg p-6">
    <div className="mb-6">
      <label className="block text-sm font-medium mb-2">활동 제목</label>
      <input 
        type="text" 
        placeholder="예: 고흐의 별이 빛나는 밤 감상하기"
        className="w-full p-3 border rounded-lg"
      />
    </div>
    
    <div className="mb-6">
      <label className="block text-sm font-medium mb-2">관찰 자료 업로드</label>
      <div className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center">
        <input type="file" accept="image/*" className="hidden" id="image-upload" />
        <label htmlFor="image-upload" className="cursor-pointer">
          <div className="text-gray-500">
            <svg className="mx-auto h-12 w-12 mb-4" fill="none" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} 
                    d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
            </svg>
            <p>이미지를 클릭하여 업로드하세요</p>
          </div>
        </label>
      </div>
    </div>
    
    <div className="mb-6">
      <label className="block text-sm font-medium mb-2">추가 안내 사항</label>
      <textarea 
        placeholder="학생들에게 전달할 추가 안내사항을 입력하세요"
        className="w-full p-3 border rounded-lg h-24"
      />
    </div>
    
    <div className="flex justify-end space-x-4">
      <button className="bg-gray-500 text-white px-6 py-3 rounded-lg">
        저장
      </button>
      <button className="bg-blue-600 text-white px-6 py-3 rounded-lg">
        학생들에게 배포
      </button>
    </div>
  </div>
</div>
```

```javascriptreact
// 학생 참여 화면
<div className="min-h-screen bg-gradient-to-br from-purple-50 to-pink-100">
  <div className="flex items-center justify-center min-h-screen">
    <div className="bg-white p-8 rounded-lg shadow-lg w-96">
      <h1 className="text-2xl font-bold text-center mb-6">
        사고루틴 참여하기
      </h1>
      <div className="mb-4">
        <label className="block text-sm font-medium mb-2">활동 코드 입력</label>
        <input 
          type="text" 
          placeholder="6자리 코드 입력"
          maxLength="6"
          className="w-full p-3 border rounded-lg text-center text-2xl font-bold tracking-widest"
          onChange={handleCodeInput}
        />
      </div>
      <div className="mb-6">
        <label className="block text-sm font-medium mb-2">이름</label>
        <input 
          type="text" 
          placeholder="이름을 입력하세요"
          className="w-full p-3 border rounded-lg"
        />
      </div>
      <button 
        onClick={joinActivity}
        className="w-full bg-purple-600 text-white p-3 rounded-lg"
      >
        활동 참여하기
      </button>
    </div>
  </div>
</div>
```

```javascriptreact
// 학생용 사고루틴 실행 화면
<div className="max-w-4xl mx-auto p-6">
  <div className="bg-white rounded-lg shadow-lg">
    {/* 헤더 */}
    <div className="bg-blue-600 text-white p-4 rounded-t-lg">
      <h1 className="text-xl font-bold">See-Think-Wonder</h1>
      <p className="text-blue-100">차근차근 따라해보세요!</p>
    </div>
    
    {/* 관찰 자료 */}
    <div className="p-6 border-b">
      <img src={activityData.image} alt="관찰 자료" className="w-full max-w-2xl mx-auto rounded-lg" />
    </div>
    
    {/* 단계별 입력 */}
    <div className="p-6 space-y-8">
      {/* SEE 단계 */}
      <div className="border-l-4 border-green-500 pl-6">
        <h3 className="text-lg font-bold text-green-700 mb-2">
          👀 SEE (관찰하기)
        </h3>
        <p className="text-gray-600 mb-4">
          무엇을 보았나요? 구체적으로 관찰한 내용을 적어보세요.
        </p>
        <textarea 
          placeholder="색깔, 모양, 크기, 위치 등을 자세히 관찰해보세요..."
          className="w-full p-4 border rounded-lg h-32"
          value={responses.see}
          onChange={(e) => updateResponse('see', e.target.value)}
        />
        <div className="text-sm text-gray-500 mt-2">
          💡 힌트: 첫 번째 느낌보다는 자세히 들여다보세요!
        </div>
      </div>
      
      {/* THINK 단계 */}
      <div className="border-l-4 border-blue-500 pl-6">
        <h3 className="text-lg font-bold text-blue-700 mb-2">
          🤔 THINK (생각하기)
        </h3>
        <p className="text-gray-600 mb-4">
          관찰한 것을 바탕으로 어떤 생각이 드나요?
        </p>
        <textarea 
          placeholder="왜 그럴까요? 어떤 의미일까요? 어떤 느낌이 드나요?"
          className="w-full p-4 border rounded-lg h-32"
          value={responses.think}
          onChange={(e) => updateResponse('think', e.target.value)}
        />
        <div className="text-sm text-gray-500 mt-2">
          💡 힌트: 관찰한 내용과 연결지어 생각해보세요!
        </div>
      </div>
      
      {/* WONDER 단계 */}
      <div className="border-l-4 border-purple-500 pl-6">
        <h3 className="text-lg font-bold text-purple-700 mb-2">
          ❓ WONDER (궁금해하기)
        </h3>
        <p className="text-gray-600 mb-4">
          어떤 점이 궁금한가요? 더 알고 싶은 것은 무엇인가요?
        </p>
        <textarea 
          placeholder="궁금한 점들을 자유롭게 적어보세요..."
          className="w-full p-4 border rounded-lg h-32"
          value={responses.wonder}
          onChange={(e) => updateResponse('wonder', e.target.value)}
        />
        <div className="text-sm text-gray-500 mt-2">
          💡 힌트: 더 탐구하고 싶은 질문을 만들어보세요!
        </div>
      </div>
    </div>
    
    {/* 제출 버튼 */}
    <div className="p-6 bg-gray-50 rounded-b-lg">
      <button 
        onClick={submitResponse}
        className="w-full bg-green-600 text-white p-4 rounded-lg font-bold"
        disabled={!isComplete}
      >
        완료하기
      </button>
    </div>
  </div>
</div>
```

```javascriptreact
// 학생 결과 확인 화면
<div className="max-w-6xl mx-auto p-6">
  <div className="flex justify-between items-center mb-6">
    <h1 className="text-2xl font-bold">학생 응답 결과</h1>
    <div className="flex space-x-4">
      <button className="bg-blue-600 text-white px-4 py-2 rounded-lg">
        전체 AI 분석
      </button>
      <button className="bg-green-600 text-white px-4 py-2 rounded-lg">
        결과 내보내기
      </button>
    </div>
  </div>
  
  <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
    {studentResponses.map(response => (
      <div key={response.id} className="bg-white rounded-lg shadow-lg p-6">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-lg font-semibold">{response.studentName}</h3>
          <span className="text-sm text-gray-500">
            {formatTime(response.submittedAt)}
          </span>
        </div>
        
        <div className="space-y-4">
          <div className="border-l-4 border-green-500 pl-4">
            <h4 className="font-medium text-green-700">SEE</h4>
            <p className="text-gray-700">{response.see}</p>
          </div>
          
          <div className="border-l-4 border-blue-500 pl-4">
            <h4 className="font-medium text-blue-700">THINK</h4>
            <p className="text-gray-700">{response.think}</p>
          </div>
          
          <div className="border-l-4 border-purple-500 pl-4">
            <h4 className="font-medium text-purple-700">WONDER</h4>
            <p className="text-gray-700">{response.wonder}</p>
          </div>
        </div>
        
        <div className="mt-4 pt-4 border-t">
          <button 
            onClick={() => analyzeResponse(response.id)}
            className="bg-orange-500 text-white px-4 py-2 rounded-lg mr-2"
          >
            AI 분석하기
          </button>
          <button 
            onClick={() => addTeacherFeedback(response.id)}
            className="bg-gray-600 text-white px-4 py-2 rounded-lg"
          >
            교사 피드백 추가
          </button>
        </div>
      </div>
    ))}
  </div>
</div>
```

```javascript
// RAG 문서 준비
const seeThinkWonderGuide = `
See-Think-Wonder 사고루틴 분석 가이드

## 목적
- 신중한 관찰 능력 개발
- 해석적 사고력 향상
- 탐구 정신 함양
- 호기심 기반 학습 촉진

## 각 단계별 평가 기준

### SEE (관찰하기)
평가 요소:
- 구체성: 세부 사항을 얼마나 자세히 관찰했는가?
- 객관성: 개인적 해석보다 사실적 관찰에 집중했는가?
- 다양성: 다양한 관점에서 관찰했는가?
- 정확성: 실제 보이는 것을 정확히 기술했는가?

우수 사례:
- "왼쪽 상단에 노란색 별들이 소용돌이 모양으로 배치되어 있다"
- "건물들은 어둡고 각진 모양이며, 창문에서 노란 빛이 새어나온다"

개선 필요 사례:
- "예쁘다", "멋있다" (감정적 표현)
- "별이 있다" (너무 단순한 관찰)

### THINK (생각하기)
평가 요소:
- 연결성: 관찰한 내용과 논리적으로 연결되었는가?
- 깊이: 표면적 생각을 넘어 깊이 있게 사고했는가?
- 추론: 관찰을 바탕으로 합리적 추론을 했는가?
- 창의성: 독창적이고 다양한 관점을 제시했는가?

우수 사례:
- "소용돌이치는 별들이 역동적인 느낌을 주어 화가의 감정 상태를 표현하는 것 같다"
- "어두운 마을과 밝은 하늘의 대비가 현실과 꿈의 경계를 나타내는 것 같다"

### WONDER (궁금해하기)
평가 요소:
- 탐구 가능성: 실제로 탐구할 수 있는 질문인가?
- 구체성: 구체적이고 명확한 질문인가?
- 확장성: 더 깊은 학습으로 이어질 수 있는가?
- 창의성: 참신하고 흥미로운 질문인가?

우수 사례:
- "왜 고흐는 밤하늘을 소용돌이 모양으로 그렸을까?"
- "이 그림을 그릴 때 고흐의 심리 상태는 어땠을까?"
- "실제 밤하늘과 다르게 표현한 이유는 무엇일까?"

## 종합 평가 기준
1. 사고의 흐름: SEE → THINK → WONDER의 논리적 연결
2. 사고의 깊이: 단계별 사고의 심화 정도
3. 창의성: 독창적이고 참신한 관점
4. 탐구 정신: 지속적인 학습 의욕 표현
`;

// AI 분석 함수
async function analyzeSTWResponse(response) {
  const prompt = `
다음은 학생이 See-Think-Wonder 사고루틴으로 작성한 응답입니다.
위의 가이드라인을 참고하여 분석해주세요.

학생 응답:
SEE: ${response.see}
THINK: ${response.think}
WONDER: ${response.wonder}

다음 형식으로 분석해주세요:

## 전체 평가
- 사고의 흐름: [SEE-THINK-WONDER 연결성 평가]
- 사고의 깊이: [각 단계별 깊이 평가]
- 종합 점수: [5점 만점]

## 단계별 분석
### SEE (관찰하기)
- 잘한 점: 
- 개선점: 
- 점수: [5점 만점]

### THINK (생각하기)
- 잘한 점:
- 개선점:
- 점수: [5점 만점]

### WONDER (궁금해하기)
- 잘한 점:
- 개선점:
- 점수: [5점 만점]

## 맞춤형 피드백
- 격려 메시지:
- 구체적 개선 제안:
- 다음 단계 학습 제안:

## 교사 참고사항
- 주목할 점:
- 추가 지도 방향:
`;

  const analysis = await openai.chat.completions.create({
    model: "gpt-4",
    messages: [
      { role: "system", content: seeThinkWonderGuide },
      { role: "user", content: prompt }
    ],
    temperature: 0.7
  });

  return analysis.choices[0].message.content;
}
```

```javascriptreact
// 피드백 편집 화면
<div className="max-w-4xl mx-auto p-6">
  <div className="bg-white rounded-lg shadow-lg p-6">
    <h2 className="text-xl font-bold mb-4">AI 분석 결과 + 교사 피드백</h2>
    
    {/* AI 분석 결과 */}
    <div className="bg-blue-50 p-4 rounded-lg mb-6">
      <h3 className="font-semibold text-blue-800 mb-2">🤖 AI 분석 결과</h3>
      <div className="whitespace-pre-wrap text-sm">
        {aiAnalysis}
      </div>
    </div>
    
    {/* 교사 피드백 추가 */}
    <div className="border-t pt-6">
      <h3 className="font-semibold mb-4">👨‍🏫 교사 피드백 추가</h3>
      
      <div className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-2">개인별 격려 메시지</label>
          <textarea 
            className="w-full p-3 border rounded-lg h-20"
            placeholder="이 학생만을 위한 개인적인 격려와 칭찬을 적어주세요..."
          />
        </div>
        
        <div>
          <label className="block text-sm font-medium mb-2">구체적 개선 제안</label>
          <textarea 
            className="w-full p-3 border rounded-lg h-20"
            placeholder="다음에 더 잘할 수 있는 구체적인 방법을 제안해주세요..."
          />
        </div>
        
        <div>
          <label className="block text-sm font-medium mb-2">추천 활동</label>
          <textarea 
            className="w-full p-3 border rounded-lg h-20"
            placeholder="이 학생에게 추천하고 싶은 후속 활동이나 자료를 제안해주세요..."
          />
        </div>
      </div>
      
      <div className="flex justify-end mt-6 space-x-4">
        <button className="bg-gray-500 text-white px-6 py-2 rounded-lg">
          임시저장
        </button>
        <button className="bg-green-600 text-white px-6 py-2 rounded-lg">
          피드백 완료
        </button>
      </div>
    </div>
  </div>
</div>
```

```javascript
// MongoDB 스키마 설계
const RoomSchema = new mongoose.Schema({
  code: { type: String, unique: true, required: true },
  title: String,
  description: String,
  teacherId: { type: mongoose.Schema.Types.ObjectId, ref: 'Teacher' },
  thinkingRoutine: {
    type: String,
    enum: ['see-think-wonder'],
    required: true
  },
  content: {
    image: String,
    instructions: String,
    additionalNotes: String
  },
  isActive: { type: Boolean, default: true },
  createdAt: { type: Date, default: Date.now },
  responses: [{
    studentName: String,
    see: String,
    think: String,
    wonder: String,
    submittedAt: Date,
    aiAnalysis: String,
    teacherFeedback: {
      encouragement: String,
      improvement: String,
      recommendations: String
    },
    finalScore: Number
  }]
});

const TeacherSchema = new mongoose.Schema({
  email: { type: String, unique: true },
  password: String,
  name: String,
  school: String,
  createdAt: { type: Date, default: Date.now }
});
```

---

**User**

우선 기술 스택 부분을
Frontend: React + Tailwind CSS
Backend: Node.js + Express
Database: MongoDB
AI: OpenAI GPT-4 + RAG (Pinecone/Weaviate)
Authentication: JWT
Real-time: Socket.io

이렇게 했는데 나는 Database는 Supabase를 사용하고 싶고 AI는 Gemini의 API를 사용할거야 그리고 내가 바라는건 학생들은 태블릿으로 할 가능성이 많아서 교사가 배포한 활동방에 참여했을 때 사고루틴을 수행하는걸 태블릿에 최적화해주면 좋겠어. 예를 들면 교사가 제공한 질문에 답을 하는 곳에 펜으로 글씨를 쓸 수 있거나 음성으로 대답하면 STT로 변환해준다거나 하는 기능이 있으면 학생들이 편할 것 같아.

---

**Cursor**

훌륭한 선택이네요! 태블릿 최적화와 다양한 입력 방식을 지원하는 것은 정말 실용적인 아이디어입니다. 수정된 기술 스택과 태블릿 친화적인 인터페이스로 다시 설계해드리겠습니다.

## 🔧 **수정된 기술 스택**

```
Frontend: React + Tailwind CSS + React Canvas Draw + React Speech Kit
Backend: Node.js + Express
Database: Supabase (PostgreSQL + Real-time + Auth)
AI: Google Gemini API + Pinecone (Vector DB for RAG)
Authentication: Supabase Auth
Real-time: Supabase Realtime
Drawing: React Canvas Draw / Fabric.js
Speech: Web Speech API (STT/TTS)
```

## 📱 **태블릿 최적화 학생 인터페이스**

### **반응형 디자인 기본 설정**
```jsx
// 태블릿 최적화 CSS 설정
const tabletOptimizedStyles = `
  /* 태블릿 기본 설정 */
  @media (min-width: 768px) and (max-width: 1024px) {
    .tablet-container {
      padding: 1rem;
      max-width: 100vw;
      min-height: 100vh;
    }
    
    .input-area {
      min-height: 200px;
      font-size: 18px;
      line-height: 1.6;
    }
    
    .touch-button {
      min-height: 60px;
      font-size: 18px;
      padding: 1rem 2rem;
    }
  }
  
  /* 터치 친화적 요소 */
  .touch-target {
    min-width: 44px;
    min-height: 44px;
    touch-action: manipulation;
  }
`;
```

### **다중 입력 방식 지원 컴포넌트**
```jsx
// MultiInputComponent.jsx
import React, { useState, useRef } from 'react';
import CanvasDraw from 'react-canvas-draw';
import SpeechRecognition, { useSpeechRecognition } from 'react-speech-kit';

const MultiInputComponent = ({ 
  placeholder, 
  value, 
  onChange, 
  step, 
  color 
}) => {
  const [inputMode, setInputMode] = useState('text'); // 'text', 'handwriting', 'voice'
  const [isRecording, setIsRecording] = useState(false);
  const canvasRef = useRef(null);
  
  const { listen, listening, stop } = useSpeechRecognition({
    onResult: (result) => {
      onChange(result);
    },
    onEnd: () => {
      setIsRecording(false);
    }
  });

  const handleVoiceInput = () => {
    if (isRecording) {
      stop();
      setIsRecording(false);
    } else {
      listen();
      setIsRecording(true);
    }
  };

  const handleCanvasChange = () => {
    // 손글씨를 이미지로 변환하여 저장
    const canvas = canvasRef.current;
    if (canvas) {
      const dataURL = canvas.canvas.drawing.toDataURL();
      onChange(dataURL, 'handwriting');
    }
  };

  return (
    <div className="bg-white rounded-xl shadow-lg p-6 tablet-container">
      {/* 입력 모드 선택 */}
      <div className="flex justify-center mb-6 space-x-4">
        <button
          onClick={() => setInputMode('text')}
          className={`touch-button rounded-lg px-6 py-3 font-medium transition-all ${
            inputMode === 'text' 
              ? 'bg-blue-600 text-white' 
              : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
          }`}
        >
          ⌨️ 키보드
        </button>
        <button
          onClick={() => setInputMode('handwriting')}
          className={`touch-button rounded-lg px-6 py-3 font-medium transition-all ${
            inputMode === 'handwriting' 
              ? 'bg-green-600 text-white' 
              : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
          }`}
        >
          ✍️ 손글씨
        </button>
        <button
          onClick={() => setInputMode('voice')}
          className={`touch-button rounded-lg px-6 py-3 font-medium transition-all ${
            inputMode === 'voice' 
              ? 'bg-purple-600 text-white' 
              : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
          }`}
        >
          🎤 음성
        </button>
      </div>

      {/* 텍스트 입력 모드 */}
      {inputMode === 'text' && (
        <div className="space-y-4">
          <textarea
            value={value}
            onChange={(e) => onChange(e.target.value)}
            placeholder={placeholder}
            className="w-full p-4 border-2 border-gray-300 rounded-lg input-area 
                     focus:border-blue-500 focus:ring-2 focus:ring-blue-200 
                     text-lg leading-relaxed resize-none"
            rows={6}
          />
          <div className="text-sm text-gray-500 text-center">
            💡 키보드로 자유롭게 입력해보세요
          </div>
        </div>
      )}

      {/* 손글씨 입력 모드 */}
      {inputMode === 'handwriting' && (
        <div className="space-y-4">
          <div className="border-2 border-gray-300 rounded-lg p-4 bg-gray-50">
            <CanvasDraw
              ref={canvasRef}
              onChange={handleCanvasChange}
              brushRadius={3}
              brushColor={color || '#000000'}
              canvasWidth={window.innerWidth > 768 ? 600 : window.innerWidth - 100}
              canvasHeight={300}
              hideGrid={true}
              className="bg-white rounded-lg"
            />
          </div>
          <div className="flex justify-center space-x-4">
            <button
              onClick={() => canvasRef.current?.clear()}
              className="bg-red-500 text-white px-6 py-3 rounded-lg touch-button"
            >
              🗑️ 지우기
            </button>
            <button
              onClick={() => canvasRef.current?.undo()}
              className="bg-gray-500 text-white px-6 py-3 rounded-lg touch-button"
            >
              ↶ 되돌리기
            </button>
          </div>
          <div className="text-sm text-gray-500 text-center">
            ✍️ 손가락이나 펜으로 자유롭게 써보세요
          </div>
        </div>
      )}

      {/* 음성 입력 모드 */}
      {inputMode === 'voice' && (
        <div className="space-y-6">
          <div className="text-center">
            <button
              onClick={handleVoiceInput}
              className={`w-32 h-32 rounded-full text-white text-2xl font-bold 
                        transition-all duration-300 ${
                isRecording 
                  ? 'bg-red-500 animate-pulse shadow-lg' 
                  : 'bg-purple-600 hover:bg-purple-700'
              }`}
            >
              {isRecording ? '🔴 녹음중' : '🎤 녹음'}
            </button>
          </div>
          
          {value && (
            <div className="bg-purple-50 p-4 rounded-lg">
              <h4 className="font-medium text-purple-800 mb-2">음성 인식 결과:</h4>
              <p className="text-purple-700 text-lg">{value}</p>
            </div>
          )}
          
          <div className="text-sm text-gray-500 text-center">
            🎤 버튼을 누르고 말해보세요. 다시 누르면 녹음이 중지됩니다.
          </div>
        </div>
      )}
    </div>
  );
};
```

### **태블릿 최적화 See-Think-Wonder 인터페이스**
```jsx
// TabletOptimizedSTW.jsx
import React, { useState, useEffect } from 'react';
import { supabase } from '../lib/supabase';
import MultiInputComponent from './MultiInputComponent';

const TabletOptimizedSTW = ({ roomCode, studentName }) => {
  const [currentStep, setCurrentStep] = useState(0);
  const [responses, setResponses] = useState({
    see: '',
    think: '',
    wonder: ''
  });
  const [activityData, setActivityData] = useState(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const steps = [
    {
      key: 'see',
      title: '👀 SEE (관찰하기)',
      color: 'green',
      description: '무엇을 보았나요? 구체적으로 관찰한 내용을 적어보세요.',
      placeholder: '색깔, 모양, 크기, 위치 등을 자세히 관찰해보세요...',
      hint: '💡 첫 번째 느낌보다는 자세히 들여다보세요!'
    },
    {
      key: 'think',
      title: '🤔 THINK (생각하기)',
      color: 'blue',
      description: '관찰한 것을 바탕으로 어떤 생각이 드나요?',
      placeholder: '왜 그럴까요? 어떤 의미일까요? 어떤 느낌이 드나요?',
      hint: '💡 관찰한 내용과 연결지어 생각해보세요!'
    },
    {
      key: 'wonder',
      title: '❓ WONDER (궁금해하기)',
      color: 'purple',
      description: '어떤 점이 궁금한가요? 더 알고 싶은 것은 무엇인가요?',
      placeholder: '궁금한 점들을 자유롭게 적어보세요...',
      hint: '💡 더 탐구하고 싶은 질문을 만들어보세요!'
    }
  ];

  const currentStepData = steps[currentStep];

  const handleResponseChange = (value, type = 'text') => {
    setResponses(prev => ({
      ...prev,
      [currentStepData.key]: value
    }));
  };

  const handleNext = () => {
    if (currentStep < steps.length - 1) {
      setCurrentStep(currentStep + 1);
    }
  };

  const handlePrevious = () => {
    if (currentStep > 0) {
      setCurrentStep(currentStep - 1);
    }
  };

  const handleSubmit = async () => {
    setIsSubmitting(true);
    try {
      const { error } = await supabase
        .from('student_responses')
        .insert({
          room_code: roomCode,
          student_name: studentName,
          see: responses.see,
          think: responses.think,
          wonder: responses.wonder,
          submitted_at: new Date().toISOString()
        });

      if (error) throw error;

      // 성공 페이지로 이동
      setCurrentStep(steps.length);
    } catch (error) {
      console.error('Error submitting response:', error);
      alert('제출 중 오류가 발생했습니다. 다시 시도해주세요.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-purple-50 p-4">
      <div className="max-w-4xl mx-auto">
        {/* 헤더 */}
        <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
          <div className="flex justify-between items-center">
            <h1 className="text-2xl font-bold text-gray-800">
              See-Think-Wonder
            </h1>
            <div className="text-sm text-gray-500">
              {studentName} | {roomCode}
            </div>
          </div>
          
          {/* 진행 상황 표시 */}
          <div className="mt-4">
            <div className="flex justify-between items-center mb-2">
              <span className="text-sm font-medium text-gray-700">
                진행 상황
              </span>
              <span className="text-sm text-gray-500">
                {currentStep + 1} / {steps.length}
              </span>
            </div>
            <div className="w-full bg-gray-200 rounded-full h-3">
              <div 
                className="bg-blue-600 h-3 rounded-full transition-all duration-500"
                style={{ width: `${((currentStep + 1) / steps.length) * 100}%` }}
              />
            </div>
          </div>
        </div>

        {/* 관찰 자료 */}
        {activityData?.image && (
          <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
            <img 
              src={activityData.image} 
              alt="관찰 자료" 
              className="w-full max-w-2xl mx-auto rounded-lg shadow-md"
            />
          </div>
        )}

        {/* 현재 단계 */}
        {currentStep < steps.length && (
          <div className="space-y-6">
            <div className="bg-white rounded-xl shadow-lg p-6">
              <div className={`border-l-4 border-${currentStepData.color}-500 pl-6`}>
                <h2 className={`text-2xl font-bold text-${currentStepData.color}-700 mb-2`}>
                  {currentStepData.title}
                </h2>
                <p className="text-gray-600 text-lg mb-4">
                  {currentStepData.description}
                </p>
              </div>
            </div>

            <MultiInputComponent
              placeholder={currentStepData.placeholder}
              value={responses[currentStepData.key]}
              onChange={handleResponseChange}
              step={currentStepData.key}
              color={currentStepData.color}
            />

            <div className="text-center text-gray-500 mb-6">
              {currentStepData.hint}
            </div>

            {/* 네비게이션 버튼 */}
            <div className="flex justify-between items-center">
              <button
                onClick={handlePrevious}
                disabled={currentStep === 0}
                className={`touch-button px-8 py-4 rounded-lg font-medium transition-all ${
                  currentStep === 0
                    ? 'bg-gray-200 text-gray-400 cursor-not-allowed'
                    : 'bg-gray-500 text-white hover:bg-gray-600'
                }`}
              >
                ← 이전
              </button>

              {currentStep < steps.length - 1 ? (
                <button
                  onClick={handleNext}
                  disabled={!responses[currentStepData.key]}
                  className={`touch-button px-8 py-4 rounded-lg font-medium transition-all ${
                    responses[currentStepData.key]
                      ? 'bg-blue-600 text-white hover:bg-blue-700'
                      : 'bg-gray-200 text-gray-400 cursor-not-allowed'
                  }`}
                >
                  다음 →
                </button>
              ) : (
                <button
                  onClick={handleSubmit}
                  disabled={!responses[currentStepData.key] || isSubmitting}
                  className={`touch-button px-8 py-4 rounded-lg font-medium transition-all ${
                    responses[currentStepData.key] && !isSubmitting
                      ? 'bg-green-600 text-white hover:bg-green-700'
                      : 'bg-gray-200 text-gray-400 cursor-not-allowed'
                  }`}
                >
                  {isSubmitting ? '제출 중...' : '완료하기 ✓'}
                </button>
              )}
            </div>
          </div>
        )}

        {/* 완료 화면 */}
        {currentStep === steps.length && (
          <div className="bg-white rounded-xl shadow-lg p-8 text-center">
            <div className="text-6xl mb-4">🎉</div>
            <h2 className="text-2xl font-bold text-green-700 mb-4">
              훌륭해요! 모든 단계를 완료했습니다!
            </h2>
            <p className="text-gray-600 text-lg mb-6">
              선생님이 여러분의 답변을 확인하고 피드백을 주실 거예요.
            </p>
            <button
              onClick={() => window.location.reload()}
              className="bg-blue-600 text-white px-8 py-4 rounded-lg touch-button"
            >
              새로운 활동 참여하기
            </button>
          </div>
        )}
      </div>
    </div>
  );
};
```

## 🗄️ **Supabase 데이터베이스 스키마**

```sql
-- 교사 테이블 (Supabase Auth 사용)
CREATE TABLE teachers (
  id UUID REFERENCES auth.users(id) PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  school TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 활동방 테이블
CREATE TABLE rooms (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  code TEXT UNIQUE NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  teacher_id UUID REFERENCES teachers(id),
  thinking_routine TEXT NOT NULL DEFAULT 'see-think-wonder',
  content JSONB NOT NULL, -- {image: string, instructions: string, additionalNotes: string}
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 학생 응답 테이블
CREATE TABLE student_responses (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  room_code TEXT REFERENCES rooms(code),
  student_name TEXT NOT NULL,
  see TEXT,
  think TEXT,
  wonder TEXT,
  see_type TEXT DEFAULT 'text', -- 'text', 'handwriting', 'voice'
  think_type TEXT DEFAULT 'text',
  wonder_type TEXT DEFAULT 'text',
  submitted_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  ai_analysis JSONB,
  teacher_feedback JSONB,
  final_score INTEGER
);

-- 인덱스 생성
CREATE INDEX idx_rooms_code ON rooms(code);
CREATE INDEX idx_rooms_teacher_id ON rooms(teacher_id);
CREATE INDEX idx_student_responses_room_code ON student_responses(room_code);
```

## 🤖 **Gemini API 기반 분석 시스템**

```javascript
// geminiAnalysis.js
import { GoogleGenerativeAI } from '@google/generative-ai';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

const seeThinkWonderPrompt = `
당신은 교육 전문가로서 초등학교 학생들의 See-Think-Wonder 사고루틴 응답을 분석하는 역할을 합니다.

See-Think-Wonder 사고루틴의 목적:
- 신중한 관찰 능력 개발
- 해석적 사고력 향상  
- 탐구 정신 함양
- 호기심 기반 학습 촉진

분석 기준:
1. SEE (관찰하기): 구체성, 객관성, 다양성, 정확성
2. THINK (생각하기): 연결성, 깊이, 추론, 창의성
3. WONDER (궁금해하기): 탐구가능성, 구체성, 확장성, 창의성

응답 형식:
- 초등학생이 이해할 수 있는 쉬운 언어 사용
- 격려와 칭찬 중심의 피드백
- 구체적이고 실행 가능한 개선 제안
- 다음 단계 학습 동기 부여
`;

export async function analyzeSTWWithGemini(studentResponse) {
  try {
    const model = genAI.getGenerativeModel({ model: 'gemini-pro' });
    
    const prompt = `
${seeThinkWonderPrompt}

학생 응답:
SEE: ${studentResponse.see}
THINK: ${studentResponse.think}
WONDER: ${studentResponse.wonder}

다음 JSON 형식으로 분석해주세요:
{
  "overallScore": 5점 만점 점수,
  "overallComment": "전체적인 평가 및 격려",
  "seeAnalysis": {
    "score": 5점 만점,
    "strengths": ["잘한 점들"],
    "improvements": ["개선점들"]
  },
  "thinkAnalysis": {
    "score": 5점 만점,
    "strengths": ["잘한 점들"],
    "improvements": ["개선점들"]
  },
  "wonderAnalysis": {
    "score": 5점 만점,
    "strengths": ["잘한 점들"],
    "improvements": ["개선점들"]
  },
  "encouragement": "학생을 격려하는 메시지",
  "nextSteps": "다음에 시도해볼 수 있는 구체적인 제안들"
}
`;

    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();
    
    // JSON 파싱 시도
    try {
      return JSON.parse(text);
    } catch (parseError) {
      // JSON 파싱 실패 시 기본 구조 반환
      return {
        overallScore: 3,
        overallComment: text,
        seeAnalysis: { score: 3, strengths: [], improvements: [] },
        thinkAnalysis: { score: 3, strengths: [], improvements: [] },
        wonderAnalysis: { score: 3, strengths: [], improvements: [] },
        encouragement: "좋은 시도였어요! 계속 노력해보세요.",
        nextSteps: "다음에는 더 자세히 관찰하고 생각해보세요."
      };
    }
  } catch (error) {
    console.error('Gemini API Error:', error);
    throw error;
  }
}
```

## 🔊 **음성 인식 및 TTS 구현**

```javascript
// speechUtils.js
export class SpeechManager {
  constructor() {
    this.recognition = null;
    this.synthesis = window.speechSynthesis;
    this.isListening = false;
  }

  // 음성 인식 시작
  startListening(onResult, onError) {
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
      onError('음성 인식을 지원하지 않는 브라우저입니다.');
      return;
    }

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    this.recognition = new SpeechRecognition();
    
    this.recognition.continuous = true;
    this.recognition.interimResults = true;
    this.recognition.lang = 'ko-KR';

    this.recognition.onresult = (event) => {
      let finalTranscript = '';
      let interimTranscript = '';

      for (let i = event.resultIndex; i < event.results.length; i++) {
        const transcript = event.results[i][0].transcript;
        if (event.results[i].isFinal) {
          finalTranscript += transcript;
        } else {
          interimTranscript += transcript;
        }
      }

      onResult(finalTranscript || interimTranscript);
    };

    this.recognition.onerror = (event) => {
      onError(`음성 인식 오류: ${event.error}`);
    };

    this.recognition.onend = () => {
      this.isListening = false;
    };

    this.recognition.start();
    this.isListening = true;
  }

  // 음성 인식 중지
  stopListening() {
    if (this.recognition && this.isListening) {
      this.recognition.stop();
      this.isListening = false;
    }
  }

  // 텍스트 음성 변환
  speak(text, lang = 'ko-KR') {
    if (this.synthesis.speaking) {
      this.synthesis.cancel();
    }

    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = lang;
    utterance.rate = 0.9;
    utterance.pitch = 1.0;
    utterance.volume = 1.0;

    this.synthesis.speak(utterance);
  }

  // 음성 중지
  stopSpeaking() {
    if (this.synthesis.speaking) {
      this.synthesis.cancel();
    }
  }
}
```

## 📱 **PWA 설정 (태블릿 앱처럼 사용)**

```json
// public/manifest.json
{
  "name": "사고루틴 학습 도구",
  "short_name": "사고루틴",
  "description": "학생들의 창의적 사고를 돕는 디지털 학습 도구",
  "start_url": "/student",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#3b82f6",
  "orientation": "landscape-primary",
  "icons": [
    {
      "src": "/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

이렇게 구현하면 학생들이 태블릿에서 편리하게 사용할 수 있는 직관적인 인터페이스를 제공할 수 있습니다! 

특히 **다중 입력 방식**(키보드, 손글씨, 음성)을 지원하여 다양한 학습 스타일의 학생들이 모두 참여할 수 있도록 했습니다. 

혹시 특정 기능에 대해 더 자세한 구현이 필요하거나 다른 질문이 있으시면 언제든 말씀해주세요! 🚀

```plaintext
Frontend: React + Tailwind CSS + React Canvas Draw + React Speech Kit
Backend: Node.js + Express
Database: Supabase (PostgreSQL + Real-time + Auth)
AI: Google Gemini API + Pinecone (Vector DB for RAG)
Authentication: Supabase Auth
Real-time: Supabase Realtime
Drawing: React Canvas Draw / Fabric.js
Speech: Web Speech API (STT/TTS)
```

```javascriptreact
// 태블릿 최적화 CSS 설정
const tabletOptimizedStyles = `
  /* 태블릿 기본 설정 */
  @media (min-width: 768px) and (max-width: 1024px) {
    .tablet-container {
      padding: 1rem;
      max-width: 100vw;
      min-height: 100vh;
    }
    
    .input-area {
      min-height: 200px;
      font-size: 18px;
      line-height: 1.6;
    }
    
    .touch-button {
      min-height: 60px;
      font-size: 18px;
      padding: 1rem 2rem;
    }
  }
  
  /* 터치 친화적 요소 */
  .touch-target {
    min-width: 44px;
    min-height: 44px;
    touch-action: manipulation;
  }
`;
```

```javascriptreact
// MultiInputComponent.jsx
import React, { useState, useRef } from 'react';
import CanvasDraw from 'react-canvas-draw';
import SpeechRecognition, { useSpeechRecognition } from 'react-speech-kit';

const MultiInputComponent = ({ 
  placeholder, 
  value, 
  onChange, 
  step, 
  color 
}) => {
  const [inputMode, setInputMode] = useState('text'); // 'text', 'handwriting', 'voice'
  const [isRecording, setIsRecording] = useState(false);
  const canvasRef = useRef(null);
  
  const { listen, listening, stop } = useSpeechRecognition({
    onResult: (result) => {
      onChange(result);
    },
    onEnd: () => {
      setIsRecording(false);
    }
  });

  const handleVoiceInput = () => {
    if (isRecording) {
      stop();
      setIsRecording(false);
    } else {
      listen();
      setIsRecording(true);
    }
  };

  const handleCanvasChange = () => {
    // 손글씨를 이미지로 변환하여 저장
    const canvas = canvasRef.current;
    if (canvas) {
      const dataURL = canvas.canvas.drawing.toDataURL();
      onChange(dataURL, 'handwriting');
    }
  };

  return (
    <div className="bg-white rounded-xl shadow-lg p-6 tablet-container">
      {/* 입력 모드 선택 */}
      <div className="flex justify-center mb-6 space-x-4">
        <button
          onClick={() => setInputMode('text')}
          className={`touch-button rounded-lg px-6 py-3 font-medium transition-all ${
            inputMode === 'text' 
              ? 'bg-blue-600 text-white' 
              : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
          }`}
        >
          ⌨️ 키보드
        </button>
        <button
          onClick={() => setInputMode('handwriting')}
          className={`touch-button rounded-lg px-6 py-3 font-medium transition-all ${
            inputMode === 'handwriting' 
              ? 'bg-green-600 text-white' 
              : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
          }`}
        >
          ✍️ 손글씨
        </button>
        <button
          onClick={() => setInputMode('voice')}
          className={`touch-button rounded-lg px-6 py-3 font-medium transition-all ${
            inputMode === 'voice' 
              ? 'bg-purple-600 text-white' 
              : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
          }`}
        >
          🎤 음성
        </button>
      </div>

      {/* 텍스트 입력 모드 */}
      {inputMode === 'text' && (
        <div className="space-y-4">
          <textarea
            value={value}
            onChange={(e) => onChange(e.target.value)}
            placeholder={placeholder}
            className="w-full p-4 border-2 border-gray-300 rounded-lg input-area 
                     focus:border-blue-500 focus:ring-2 focus:ring-blue-200 
                     text-lg leading-relaxed resize-none"
            rows={6}
          />
          <div className="text-sm text-gray-500 text-center">
            💡 키보드로 자유롭게 입력해보세요
          </div>
        </div>
      )}

      {/* 손글씨 입력 모드 */}
      {inputMode === 'handwriting' && (
        <div className="space-y-4">
          <div className="border-2 border-gray-300 rounded-lg p-4 bg-gray-50">
            <CanvasDraw
              ref={canvasRef}
              onChange={handleCanvasChange}
              brushRadius={3}
              brushColor={color || '#000000'}
              canvasWidth={window.innerWidth > 768 ? 600 : window.innerWidth - 100}
              canvasHeight={300}
              hideGrid={true}
              className="bg-white rounded-lg"
            />
          </div>
          <div className="flex justify-center space-x-4">
            <button
              onClick={() => canvasRef.current?.clear()}
              className="bg-red-500 text-white px-6 py-3 rounded-lg touch-button"
            >
              🗑️ 지우기
            </button>
            <button
              onClick={() => canvasRef.current?.undo()}
              className="bg-gray-500 text-white px-6 py-3 rounded-lg touch-button"
            >
              ↶ 되돌리기
            </button>
          </div>
          <div className="text-sm text-gray-500 text-center">
            ✍️ 손가락이나 펜으로 자유롭게 써보세요
          </div>
        </div>
      )}

      {/* 음성 입력 모드 */}
      {inputMode === 'voice' && (
        <div className="space-y-6">
          <div className="text-center">
            <button
              onClick={handleVoiceInput}
              className={`w-32 h-32 rounded-full text-white text-2xl font-bold 
                        transition-all duration-300 ${
                isRecording 
                  ? 'bg-red-500 animate-pulse shadow-lg' 
                  : 'bg-purple-600 hover:bg-purple-700'
              }`}
            >
              {isRecording ? '🔴 녹음중' : '🎤 녹음'}
            </button>
          </div>
          
          {value && (
            <div className="bg-purple-50 p-4 rounded-lg">
              <h4 className="font-medium text-purple-800 mb-2">음성 인식 결과:</h4>
              <p className="text-purple-700 text-lg">{value}</p>
            </div>
          )}
          
          <div className="text-sm text-gray-500 text-center">
            🎤 버튼을 누르고 말해보세요. 다시 누르면 녹음이 중지됩니다.
          </div>
        </div>
      )}
    </div>
  );
};
```

```javascriptreact
// TabletOptimizedSTW.jsx
import React, { useState, useEffect } from 'react';
import { supabase } from '../lib/supabase';
import MultiInputComponent from './MultiInputComponent';

const TabletOptimizedSTW = ({ roomCode, studentName }) => {
  const [currentStep, setCurrentStep] = useState(0);
  const [responses, setResponses] = useState({
    see: '',
    think: '',
    wonder: ''
  });
  const [activityData, setActivityData] = useState(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const steps = [
    {
      key: 'see',
      title: '👀 SEE (관찰하기)',
      color: 'green',
      description: '무엇을 보았나요? 구체적으로 관찰한 내용을 적어보세요.',
      placeholder: '색깔, 모양, 크기, 위치 등을 자세히 관찰해보세요...',
      hint: '💡 첫 번째 느낌보다는 자세히 들여다보세요!'
    },
    {
      key: 'think',
      title: '🤔 THINK (생각하기)',
      color: 'blue',
      description: '관찰한 것을 바탕으로 어떤 생각이 드나요?',
      placeholder: '왜 그럴까요? 어떤 의미일까요? 어떤 느낌이 드나요?',
      hint: '💡 관찰한 내용과 연결지어 생각해보세요!'
    },
    {
      key: 'wonder',
      title: '❓ WONDER (궁금해하기)',
      color: 'purple',
      description: '어떤 점이 궁금한가요? 더 알고 싶은 것은 무엇인가요?',
      placeholder: '궁금한 점들을 자유롭게 적어보세요...',
      hint: '💡 더 탐구하고 싶은 질문을 만들어보세요!'
    }
  ];

  const currentStepData = steps[currentStep];

  const handleResponseChange = (value, type = 'text') => {
    setResponses(prev => ({
      ...prev,
      [currentStepData.key]: value
    }));
  };

  const handleNext = () => {
    if (currentStep < steps.length - 1) {
      setCurrentStep(currentStep + 1);
    }
  };

  const handlePrevious = () => {
    if (currentStep > 0) {
      setCurrentStep(currentStep - 1);
    }
  };

  const handleSubmit = async () => {
    setIsSubmitting(true);
    try {
      const { error } = await supabase
        .from('student_responses')
        .insert({
          room_code: roomCode,
          student_name: studentName,
          see: responses.see,
          think: responses.think,
          wonder: responses.wonder,
          submitted_at: new Date().toISOString()
        });

      if (error) throw error;

      // 성공 페이지로 이동
      setCurrentStep(steps.length);
    } catch (error) {
      console.error('Error submitting response:', error);
      alert('제출 중 오류가 발생했습니다. 다시 시도해주세요.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-purple-50 p-4">
      <div className="max-w-4xl mx-auto">
        {/* 헤더 */}
        <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
          <div className="flex justify-between items-center">
            <h1 className="text-2xl font-bold text-gray-800">
              See-Think-Wonder
            </h1>
            <div className="text-sm text-gray-500">
              {studentName} | {roomCode}
            </div>
          </div>
          
          {/* 진행 상황 표시 */}
          <div className="mt-4">
            <div className="flex justify-between items-center mb-2">
              <span className="text-sm font-medium text-gray-700">
                진행 상황
              </span>
              <span className="text-sm text-gray-500">
                {currentStep + 1} / {steps.length}
              </span>
            </div>
            <div className="w-full bg-gray-200 rounded-full h-3">
              <div 
                className="bg-blue-600 h-3 rounded-full transition-all duration-500"
                style={{ width: `${((currentStep + 1) / steps.length) * 100}%` }}
              />
            </div>
          </div>
        </div>

        {/* 관찰 자료 */}
        {activityData?.image && (
          <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
            <img 
              src={activityData.image} 
              alt="관찰 자료" 
              className="w-full max-w-2xl mx-auto rounded-lg shadow-md"
            />
          </div>
        )}

        {/* 현재 단계 */}
        {currentStep < steps.length && (
          <div className="space-y-6">
            <div className="bg-white rounded-xl shadow-lg p-6">
              <div className={`border-l-4 border-${currentStepData.color}-500 pl-6`}>
                <h2 className={`text-2xl font-bold text-${currentStepData.color}-700 mb-2`}>
                  {currentStepData.title}
                </h2>
                <p className="text-gray-600 text-lg mb-4">
                  {currentStepData.description}
                </p>
              </div>
            </div>

            <MultiInputComponent
              placeholder={currentStepData.placeholder}
              value={responses[currentStepData.key]}
              onChange={handleResponseChange}
              step={currentStepData.key}
              color={currentStepData.color}
            />

            <div className="text-center text-gray-500 mb-6">
              {currentStepData.hint}
            </div>

            {/* 네비게이션 버튼 */}
            <div className="flex justify-between items-center">
              <button
                onClick={handlePrevious}
                disabled={currentStep === 0}
                className={`touch-button px-8 py-4 rounded-lg font-medium transition-all ${
                  currentStep === 0
                    ? 'bg-gray-200 text-gray-400 cursor-not-allowed'
                    : 'bg-gray-500 text-white hover:bg-gray-600'
                }`}
              >
                ← 이전
              </button>

              {currentStep < steps.length - 1 ? (
                <button
                  onClick={handleNext}
                  disabled={!responses[currentStepData.key]}
                  className={`touch-button px-8 py-4 rounded-lg font-medium transition-all ${
                    responses[currentStepData.key]
                      ? 'bg-blue-600 text-white hover:bg-blue-700'
                      : 'bg-gray-200 text-gray-400 cursor-not-allowed'
                  }`}
                >
                  다음 →
                </button>
              ) : (
                <button
                  onClick={handleSubmit}
                  disabled={!responses[currentStepData.key] || isSubmitting}
                  className={`touch-button px-8 py-4 rounded-lg font-medium transition-all ${
                    responses[currentStepData.key] && !isSubmitting
                      ? 'bg-green-600 text-white hover:bg-green-700'
                      : 'bg-gray-200 text-gray-400 cursor-not-allowed'
                  }`}
                >
                  {isSubmitting ? '제출 중...' : '완료하기 ✓'}
                </button>
              )}
            </div>
          </div>
        )}

        {/* 완료 화면 */}
        {currentStep === steps.length && (
          <div className="bg-white rounded-xl shadow-lg p-8 text-center">
            <div className="text-6xl mb-4">🎉</div>
            <h2 className="text-2xl font-bold text-green-700 mb-4">
              훌륭해요! 모든 단계를 완료했습니다!
            </h2>
            <p className="text-gray-600 text-lg mb-6">
              선생님이 여러분의 답변을 확인하고 피드백을 주실 거예요.
            </p>
            <button
              onClick={() => window.location.reload()}
              className="bg-blue-600 text-white px-8 py-4 rounded-lg touch-button"
            >
              새로운 활동 참여하기
            </button>
          </div>
        )}
      </div>
    </div>
  );
};
```

```sql
-- 교사 테이블 (Supabase Auth 사용)
CREATE TABLE teachers (
  id UUID REFERENCES auth.users(id) PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  school TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 활동방 테이블
CREATE TABLE rooms (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  code TEXT UNIQUE NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  teacher_id UUID REFERENCES teachers(id),
  thinking_routine TEXT NOT NULL DEFAULT 'see-think-wonder',
  content JSONB NOT NULL, -- {image: string, instructions: string, additionalNotes: string}
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 학생 응답 테이블
CREATE TABLE student_responses (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  room_code TEXT REFERENCES rooms(code),
  student_name TEXT NOT NULL,
  see TEXT,
  think TEXT,
  wonder TEXT,
  see_type TEXT DEFAULT 'text', -- 'text', 'handwriting', 'voice'
  think_type TEXT DEFAULT 'text',
  wonder_type TEXT DEFAULT 'text',
  submitted_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  ai_analysis JSONB,
  teacher_feedback JSONB,
  final_score INTEGER
);

-- 인덱스 생성
CREATE INDEX idx_rooms_code ON rooms(code);
CREATE INDEX idx_rooms_teacher_id ON rooms(teacher_id);
CREATE INDEX idx_student_responses_room_code ON student_responses(room_code);
```

```javascript
// geminiAnalysis.js
import { GoogleGenerativeAI } from '@google/generative-ai';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

const seeThinkWonderPrompt = `
당신은 교육 전문가로서 초등학교 학생들의 See-Think-Wonder 사고루틴 응답을 분석하는 역할을 합니다.

See-Think-Wonder 사고루틴의 목적:
- 신중한 관찰 능력 개발
- 해석적 사고력 향상  
- 탐구 정신 함양
- 호기심 기반 학습 촉진

분석 기준:
1. SEE (관찰하기): 구체성, 객관성, 다양성, 정확성
2. THINK (생각하기): 연결성, 깊이, 추론, 창의성
3. WONDER (궁금해하기): 탐구가능성, 구체성, 확장성, 창의성

응답 형식:
- 초등학생이 이해할 수 있는 쉬운 언어 사용
- 격려와 칭찬 중심의 피드백
- 구체적이고 실행 가능한 개선 제안
- 다음 단계 학습 동기 부여
`;

export async function analyzeSTWWithGemini(studentResponse) {
  try {
    const model = genAI.getGenerativeModel({ model: 'gemini-pro' });
    
    const prompt = `
${seeThinkWonderPrompt}

학생 응답:
SEE: ${studentResponse.see}
THINK: ${studentResponse.think}
WONDER: ${studentResponse.wonder}

다음 JSON 형식으로 분석해주세요:
{
  "overallScore": 5점 만점 점수,
  "overallComment": "전체적인 평가 및 격려",
  "seeAnalysis": {
    "score": 5점 만점,
    "strengths": ["잘한 점들"],
    "improvements": ["개선점들"]
  },
  "thinkAnalysis": {
    "score": 5점 만점,
    "strengths": ["잘한 점들"],
    "improvements": ["개선점들"]
  },
  "wonderAnalysis": {
    "score": 5점 만점,
    "strengths": ["잘한 점들"],
    "improvements": ["개선점들"]
  },
  "encouragement": "학생을 격려하는 메시지",
  "nextSteps": "다음에 시도해볼 수 있는 구체적인 제안들"
}
`;

    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();
    
    // JSON 파싱 시도
    try {
      return JSON.parse(text);
    } catch (parseError) {
      // JSON 파싱 실패 시 기본 구조 반환
      return {
        overallScore: 3,
        overallComment: text,
        seeAnalysis: { score: 3, strengths: [], improvements: [] },
        thinkAnalysis: { score: 3, strengths: [], improvements: [] },
        wonderAnalysis: { score: 3, strengths: [], improvements: [] },
        encouragement: "좋은 시도였어요! 계속 노력해보세요.",
        nextSteps: "다음에는 더 자세히 관찰하고 생각해보세요."
      };
    }
  } catch (error) {
    console.error('Gemini API Error:', error);
    throw error;
  }
}
```

```javascript
// speechUtils.js
export class SpeechManager {
  constructor() {
    this.recognition = null;
    this.synthesis = window.speechSynthesis;
    this.isListening = false;
  }

  // 음성 인식 시작
  startListening(onResult, onError) {
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
      onError('음성 인식을 지원하지 않는 브라우저입니다.');
      return;
    }

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    this.recognition = new SpeechRecognition();
    
    this.recognition.continuous = true;
    this.recognition.interimResults = true;
    this.recognition.lang = 'ko-KR';

    this.recognition.onresult = (event) => {
      let finalTranscript = '';
      let interimTranscript = '';

      for (let i = event.resultIndex; i < event.results.length; i++) {
        const transcript = event.results[i][0].transcript;
        if (event.results[i].isFinal) {
          finalTranscript += transcript;
        } else {
          interimTranscript += transcript;
        }
      }

      onResult(finalTranscript || interimTranscript);
    };

    this.recognition.onerror = (event) => {
      onError(`음성 인식 오류: ${event.error}`);
    };

    this.recognition.onend = () => {
      this.isListening = false;
    };

    this.recognition.start();
    this.isListening = true;
  }

  // 음성 인식 중지
  stopListening() {
    if (this.recognition && this.isListening) {
      this.recognition.stop();
      this.isListening = false;
    }
  }

  // 텍스트 음성 변환
  speak(text, lang = 'ko-KR') {
    if (this.synthesis.speaking) {
      this.synthesis.cancel();
    }

    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = lang;
    utterance.rate = 0.9;
    utterance.pitch = 1.0;
    utterance.volume = 1.0;

    this.synthesis.speak(utterance);
  }

  // 음성 중지
  stopSpeaking() {
    if (this.synthesis.speaking) {
      this.synthesis.cancel();
    }
  }
}
```

```json
// public/manifest.json
{
  "name": "사고루틴 학습 도구",
  "short_name": "사고루틴",
  "description": "학생들의 창의적 사고를 돕는 디지털 학습 도구",
  "start_url": "/student",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#3b82f6",
  "orientation": "landscape-primary",
  "icons": [
    {
      "src": "/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

---

**User**

RAG 기반 AI 분석은 어떤 구조로 만들었는지 궁금하네

---

**Cursor**

좋은 질문이네요! RAG(Retrieval-Augmented Generation) 기반 AI 분석 시스템의 구조를 자세히 설명해드리겠습니다.

## 🏗️ **RAG 시스템 전체 구조**

```
RAG 기반 분석 시스템
├── 1. 지식 베이스 구축 (Knowledge Base)
├── 2. 벡터 임베딩 및 저장 (Vector Store)
├── 3. 검색 시스템 (Retrieval)
├── 4. 컨텍스트 생성 (Context Generation)
└── 5. AI 분석 및 응답 생성 (Generation)
```

## 📚 **1단계: 지식 베이스 구축**

### **사고루틴 전문 문서 데이터베이스**
```javascript
// knowledgeBase.js
export const seeThinkWonderKnowledge = {
  // 기본 정보
  basic: {
    title: "See-Think-Wonder 사고루틴",
    purpose: "신중한 관찰, 해석적 사고, 탐구 정신 함양",
    developedBy: "Project Zero, Harvard Graduate School of Education",
    targetAge: "초등학생부터 성인까지",
    duration: "15-30분"
  },

  // 각 단계별 상세 가이드
  stages: {
    see: {
      title: "SEE (관찰하기)",
      objective: "객관적이고 구체적인 관찰 능력 개발",
      criteria: {
        specificity: "세부 사항을 얼마나 자세히 관찰했는가?",
        objectivity: "개인적 해석보다 사실적 관찰에 집중했는가?",
        diversity: "다양한 관점에서 관찰했는가?",
        accuracy: "실제 보이는 것을 정확히 기술했는가?"
      },
      excellentExamples: [
        "왼쪽 상단에 노란색 별들이 소용돌이 모양으로 배치되어 있다",
        "건물들은 어둡고 각진 모양이며, 창문에서 노란 빛이 새어나온다",
        "하늘의 3분의 2가 파란색과 노란색의 소용돌이로 채워져 있다"
      ],
      needsImprovementExamples: [
        "예쁘다", "멋있다", "좋다", // 감정적 표현
        "별이 있다", "집이 있다", // 너무 단순한 관찰
        "신비로워 보인다" // 해석이 섞인 관찰
      ],
      guidingQuestions: [
        "어떤 색깔들이 보이나요?",
        "어떤 모양들이 있나요?",
        "크기는 어떤가요?",
        "위치는 어디에 있나요?",
        "질감은 어떻게 보이나요?"
      ]
    },
    
    think: {
      title: "THINK (생각하기)",
      objective: "관찰을 바탕으로 한 해석적 사고력 개발",
      criteria: {
        connection: "관찰한 내용과 논리적으로 연결되었는가?",
        depth: "표면적 생각을 넘어 깊이 있게 사고했는가?",
        reasoning: "관찰을 바탕으로 합리적 추론을 했는가?",
        creativity: "독창적이고 다양한 관점을 제시했는가?"
      },
      excellentExamples: [
        "소용돌이치는 별들이 역동적인 느낌을 주어 화가의 감정 상태를 표현하는 것 같다",
        "어두운 마을과 밝은 하늘의 대비가 현실과 꿈의 경계를 나타내는 것 같다",
        "굵고 흐르는 붓터치가 바람의 움직임을 표현하려 한 것 같다"
      ],
      needsImprovementExamples: [
        "좋은 그림이다", // 평가적 표현
        "밤이다", // 단순한 사실 확인
        "예술가가 그렸다" // 당연한 추론
      ],
      guidingQuestions: [
        "왜 이런 색을 사용했을까요?",
        "작가가 무엇을 표현하려 했을까요?",
        "어떤 느낌이나 분위기를 주나요?",
        "다른 작품과 비교했을 때 어떤 특징이 있나요?"
      ]
    },
    
    wonder: {
      title: "WONDER (궁금해하기)",
      objective: "탐구 정신과 호기심 기반 학습 촉진",
      criteria: {
        investigatable: "실제로 탐구할 수 있는 질문인가?",
        specificity: "구체적이고 명확한 질문인가?",
        expandability: "더 깊은 학습으로 이어질 수 있는가?",
        creativity: "참신하고 흥미로운 질문인가?"
      },
      excellentExamples: [
        "왜 고흐는 밤하늘을 소용돌이 모양으로 그렸을까?",
        "이 그림을 그릴 때 고흐의 심리 상태는 어땠을까?",
        "실제 밤하늘과 다르게 표현한 이유는 무엇일까?",
        "다른 화가들은 밤하늘을 어떻게 그렸을까?"
      ],
      needsImprovementExamples: [
        "누가 그렸나요?", // 단순한 정보 질문
        "언제 그렸나요?", // 검색으로 쉽게 찾을 수 있는 질문
        "좋은 그림인가요?" // 주관적 판단 질문
      ],
      guidingQuestions: [
        "더 알고 싶은 것은 무엇인가요?",
        "어떤 부분이 가장 궁금한가요?",
        "다른 관점에서 보면 어떤 질문이 생기나요?",
        "이것과 관련된 다른 주제는 무엇일까요?"
      ]
    }
  },

  // 연령별 특성
  ageCharacteristics: {
    elementary: {
      strengths: ["직관적 관찰", "솔직한 표현", "무한한 호기심"],
      challenges: ["추상적 사고 어려움", "어휘력 한계", "집중력 부족"],
      adaptations: ["구체적 예시 제공", "단순한 언어 사용", "시각적 도구 활용"]
    }
  },

  // 평가 루브릭
  rubric: {
    excellent: {
      score: 5,
      see: "매우 구체적이고 다양한 관점에서 객관적으로 관찰",
      think: "관찰과 논리적으로 연결된 깊이 있고 창의적인 사고",
      wonder: "탐구 가능하고 확장성 있는 구체적이고 창의적인 질문"
    },
    good: {
      score: 4,
      see: "구체적이고 객관적인 관찰",
      think: "관찰과 연결된 적절한 수준의 사고",
      wonder: "탐구 가능한 구체적인 질문"
    },
    satisfactory: {
      score: 3,
      see: "기본적인 관찰 내용 포함",
      think: "관찰과 어느 정도 연결된 사고",
      wonder: "기본적인 질문 제시"
    },
    needsImprovement: {
      score: 2,
      see: "단순하거나 주관적인 관찰",
      think: "관찰과 연결성이 부족한 사고",
      wonder: "단순하거나 탐구하기 어려운 질문"
    },
    insufficient: {
      score: 1,
      see: "매우 단순하거나 부정확한 관찰",
      think: "관찰과 무관하거나 부적절한 사고",
      wonder: "질문이 없거나 부적절한 질문"
    }
  }
};
```

## 🔍 **2단계: 벡터 임베딩 및 저장**

### **Pinecone을 이용한 벡터 데이터베이스**
```javascript
// vectorStore.js
import { Pinecone } from '@pinecone-database/pinecone';
import { GoogleGenerativeAI } from '@google/generative-ai';

class VectorStore {
  constructor() {
    this.pinecone = new Pinecone({
      apiKey: process.env.PINECONE_API_KEY,
    });
    this.genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
    this.index = this.pinecone.index('thinking-routines');
  }

  // 텍스트를 벡터로 변환
  async createEmbedding(text) {
    try {
      const model = this.genAI.getGenerativeModel({ model: 'embedding-001' });
      const result = await model.embedContent(text);
      return result.embedding.values;
    } catch (error) {
      console.error('Embedding creation error:', error);
      throw error;
    }
  }

  // 지식 베이스를 벡터로 변환하여 저장
  async indexKnowledgeBase() {
    const documents = this.prepareDocuments();
    
    for (const doc of documents) {
      const embedding = await this.createEmbedding(doc.content);
      
      await this.index.upsert([{
        id: doc.id,
        values: embedding,
        metadata: {
          type: doc.type,
          stage: doc.stage,
          category: doc.category,
          content: doc.content,
          examples: doc.examples || [],
          criteria: doc.criteria || {}
        }
      }]);
    }
  }

  // 문서 준비
  prepareDocuments() {
    const documents = [];
    
    // SEE 단계 문서들
    documents.push({
      id: 'see-objectives',
      type: 'stage-guide',
      stage: 'see',
      category: 'objectives',
      content: `SEE 단계의 목적: ${seeThinkWonderKnowledge.stages.see.objective}`,
    });

    documents.push({
      id: 'see-criteria',
      type: 'evaluation-criteria',
      stage: 'see',
      category: 'criteria',
      content: `SEE 단계 평가 기준: ${JSON.stringify(seeThinkWonderKnowledge.stages.see.criteria)}`,
      criteria: seeThinkWonderKnowledge.stages.see.criteria
    });

    documents.push({
      id: 'see-examples',
      type: 'examples',
      stage: 'see',
      category: 'excellent',
      content: `SEE 단계 우수 사례: ${seeThinkWonderKnowledge.stages.see.excellentExamples.join(', ')}`,
      examples: seeThinkWonderKnowledge.stages.see.excellentExamples
    });

    // THINK, WONDER 단계도 동일하게 처리...
    
    return documents;
  }

  // 관련 문서 검색
  async searchRelevantDocs(query, stage = null, topK = 5) {
    const queryEmbedding = await this.createEmbedding(query);
    
    const searchRequest = {
      vector: queryEmbedding,
      topK: topK,
      includeMetadata: true
    };

    if (stage) {
      searchRequest.filter = { stage: { $eq: stage } };
    }

    const results = await this.index.query(searchRequest);
    return results.matches.map(match => ({
      score: match.score,
      content: match.metadata.content,
      type: match.metadata.type,
      stage: match.metadata.stage,
      category: match.metadata.category,
      examples: match.metadata.examples || [],
      criteria: match.metadata.criteria || {}
    }));
  }
}
```

## 🤖 **3단계: RAG 기반 분석 시스템**

### **컨텍스트 생성 및 AI 분석**
```javascript
// ragAnalyzer.js
import { VectorStore } from './vectorStore.js';
import { GoogleGenerativeAI } from '@google/generative-ai';

class RAGAnalyzer {
  constructor() {
    this.vectorStore = new VectorStore();
    this.genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
  }

  async analyzeStudentResponse(studentResponse) {
    // 1. 각 단계별로 관련 문서 검색
    const seeContext = await this.vectorStore.searchRelevantDocs(
      studentResponse.see, 'see', 3
    );
    
    const thinkContext = await this.vectorStore.searchRelevantDocs(
      studentResponse.think, 'think', 3
    );
    
    const wonderContext = await this.vectorStore.searchRelevantDocs(
      studentResponse.wonder, 'wonder', 3
    );

    // 2. 전체적인 맥락 검색
    const overallQuery = `${studentResponse.see} ${studentResponse.think} ${studentResponse.wonder}`;
    const overallContext = await this.vectorStore.searchRelevantDocs(
      overallQuery, null, 5
    );

    // 3. 컨텍스트 생성
    const context = this.buildContext(seeContext, thinkContext, wonderContext, overallContext);

    // 4. AI 분석 수행
    return await this.performAnalysis(studentResponse, context);
  }

  buildContext(seeContext, thinkContext, wonderContext, overallContext) {
    return {
      seeGuidelines: seeContext.map(doc => ({
        type: doc.type,
        content: doc.content,
        examples: doc.examples,
        criteria: doc.criteria
      })),
      thinkGuidelines: thinkContext.map(doc => ({
        type: doc.type,
        content: doc.content,
        examples: doc.examples,
        criteria: doc.criteria
      })),
      wonderGuidelines: wonderContext.map(doc => ({
        type: doc.type,
        content: doc.content,
        examples: doc.examples,
        criteria: doc.criteria
      })),
      overallGuidelines: overallContext.map(doc => ({
        type: doc.type,
        content: doc.content,
        stage: doc.stage
      }))
    };
  }

  async performAnalysis(studentResponse, context) {
    const model = this.genAI.getGenerativeModel({ model: 'gemini-pro' });
    
    const prompt = this.buildAnalysisPrompt(studentResponse, context);
    
    try {
      const result = await model.generateContent(prompt);
      const response = await result.response;
      const analysisText = response.text();
      
      // JSON 파싱 시도
      const analysis = JSON.parse(analysisText);
      
      // 분석 결과 후처리
      return this.postProcessAnalysis(analysis, context);
      
    } catch (error) {
      console.error('Analysis error:', error);
      return this.getDefaultAnalysis();
    }
  }

  buildAnalysisPrompt(studentResponse, context) {
    return `
당신은 See-Think-Wonder 사고루틴 전문 분석가입니다.
다음 컨텍스트를 참고하여 학생의 응답을 분석해주세요.

## 컨텍스트 정보

### SEE 단계 가이드라인:
${context.seeGuidelines.map(guide => `
- ${guide.content}
- 평가 기준: ${JSON.stringify(guide.criteria)}
- 우수 사례: ${guide.examples.join(', ')}
`).join('\n')}

### THINK 단계 가이드라인:
${context.thinkGuidelines.map(guide => `
- ${guide.content}
- 평가 기준: ${JSON.stringify(guide.criteria)}
- 우수 사례: ${guide.examples.join(', ')}
`).join('\n')}

### WONDER 단계 가이드라인:
${context.wonderGuidelines.map(guide => `
- ${guide.content}
- 평가 기준: ${JSON.stringify(guide.criteria)}
- 우수 사례: ${guide.examples.join(', ')}
`).join('\n')}

## 학생 응답
SEE: ${studentResponse.see}
THINK: ${studentResponse.think}
WONDER: ${studentResponse.wonder}

## 분석 요청
위의 전문 가이드라인을 바탕으로 학생의 응답을 분석하고, 
다음 JSON 형식으로 결과를 제공해주세요:

{
  "overallScore": 5,
  "overallComment": "전체적인 평가 및 격려 메시지",
  "seeAnalysis": {
    "score": 4,
    "strengths": ["구체적인 관찰", "다양한 요소 포함"],
    "improvements": ["객관성 향상 필요"],
    "feedback": "학생 맞춤형 피드백",
    "matchedCriteria": ["specificity", "diversity"],
    "suggestedExamples": ["개선을 위한 예시"]
  },
  "thinkAnalysis": {
    "score": 4,
    "strengths": ["논리적 연결", "창의적 사고"],
    "improvements": ["더 깊은 분석 필요"],
    "feedback": "학생 맞춤형 피드백",
    "matchedCriteria": ["connection", "creativity"],
    "suggestedExamples": ["개선을 위한 예시"]
  },
  "wonderAnalysis": {
    "score": 3,
    "strengths": ["구체적 질문"],
    "improvements": ["탐구 가능성 향상"],
    "feedback": "학생 맞춤형 피드백",
    "matchedCriteria": ["specificity"],
    "suggestedExamples": ["개선을 위한 예시"]
  },
  "encouragement": "개인화된 격려 메시지",
  "nextSteps": ["구체적인 다음 단계 제안"],
  "teacherNotes": "교사를 위한 추가 지도 방향"
}

분석 시 주의사항:
1. 초등학생 수준에 맞는 언어와 피드백 사용
2. 긍정적이고 격려하는 톤 유지
3. 구체적이고 실행 가능한 개선 제안
4. 학생의 노력과 시도를 인정하고 칭찬
5. 각 단계별 전문 기준에 따른 정확한 평가
`;
  }

  postProcessAnalysis(analysis, context) {
    // 분석 결과에 추가 정보 보강
    return {
      ...analysis,
      analysisTimestamp: new Date().toISOString(),
      contextUsed: {
        seeDocuments: context.seeGuidelines.length,
        thinkDocuments: context.thinkGuidelines.length,
        wonderDocuments: context.wonderGuidelines.length,
        overallDocuments: context.overallGuidelines.length
      },
      confidence: this.calculateConfidence(analysis),
      recommendations: this.generateRecommendations(analysis)
    };
  }

  calculateConfidence(analysis) {
    // 분석 결과의 신뢰도 계산
    const scores = [
      analysis.seeAnalysis.score,
      analysis.thinkAnalysis.score,
      analysis.wonderAnalysis.score
    ];
    
    const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
    const variance = scores.reduce((acc, score) => acc + Math.pow(score - avgScore, 2), 0) / scores.length;
    
    // 점수가 일관되고 높을수록 신뢰도 높음
    return Math.max(0, Math.min(1, (avgScore / 5) * (1 - variance / 5)));
  }

  generateRecommendations(analysis) {
    const recommendations = [];
    
    // 각 단계별 점수에 따른 추천 활동
    if (analysis.seeAnalysis.score < 3) {
      recommendations.push({
        type: 'observation',
        activity: '관찰 게임을 통한 세부 사항 찾기 연습',
        priority: 'high'
      });
    }
    
    if (analysis.thinkAnalysis.score < 3) {
      recommendations.push({
        type: 'thinking',
        activity: '왜? 어떻게? 질문을 통한 사고 확장 연습',
        priority: 'medium'
      });
    }
    
    if (analysis.wonderAnalysis.score < 3) {
      recommendations.push({
        type: 'inquiry',
        activity: '질문 만들기 게임을 통한 탐구 정신 기르기',
        priority: 'medium'
      });
    }
    
    return recommendations;
  }

  getDefaultAnalysis() {
    return {
      overallScore: 3,
      overallComment: "좋은 시도였어요! 각 단계를 모두 완성했네요.",
      seeAnalysis: {
        score: 3,
        strengths: ["관찰을 시도했어요"],
        improvements: ["더 자세히 관찰해보세요"],
        feedback: "다음에는 색깔, 모양, 크기 등을 더 구체적으로 적어보세요.",
        matchedCriteria: [],
        suggestedExamples: []
      },
      thinkAnalysis: {
        score: 3,
        strengths: ["생각을 표현했어요"],
        improvements: ["관찰한 내용과 연결해보세요"],
        feedback: "관찰한 것을 바탕으로 왜 그럴까 생각해보세요.",
        matchedCriteria: [],
        suggestedExamples: []
      },
      wonderAnalysis: {
        score: 3,
        strengths: ["궁금한 점을 생각했어요"],
        improvements: ["더 구체적인 질문을 만들어보세요"],
        feedback: "궁금한 점을 더 자세히 질문으로 만들어보세요.",
        matchedCriteria: [],
        suggestedExamples: []
      },
      encouragement: "계속 노력하면 더 잘할 수 있을 거예요!",
      nextSteps: ["다음에는 더 자세히 관찰하고 생각해보세요"],
      teacherNotes: "기본적인 참여는 이루어졌으나 각 단계별 심화 지도가 필요합니다."
    };
  }
}

export { RAGAnalyzer };
```

## 🔄 **4단계: 실시간 분석 시스템**

### **API 엔드포인트**
```javascript
// routes/analysis.js
import express from 'express';
import { RAGAnalyzer } from '../services/ragAnalyzer.js';
import { supabase } from '../lib/supabase.js';

const router = express.Router();
const ragAnalyzer = new RAGAnalyzer();

// 개별 학생 응답 분석
router.post('/analyze/:responseId', async (req, res) => {
  try {
    const { responseId } = req.params;
    
    // 학생 응답 조회
    const { data: response, error } = await supabase
      .from('student_responses')
      .select('*')
      .eq('id', responseId)
      .single();
    
    if (error) throw error;
    
    // RAG 분석 수행
    const analysis = await ragAnalyzer.analyzeStudentResponse({
      see: response.see,
      think: response.think,
      wonder: response.wonder
    });
    
    // 분석 결과 저장
    const { error: updateError } = await supabase
      .from('student_responses')
      .update({
        ai_analysis: analysis,
        analyzed_at: new Date().toISOString()
      })
      .eq('id', responseId);
    
    if (updateError) throw updateError;
    
    res.json({
      success: true,
      analysis: analysis
    });
    
  } catch (error) {
    console.error('Analysis error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// 전체 활동방 분석
router.post('/analyze-room/:roomCode', async (req, res) => {
  try {
    const { roomCode } = req.params;
    
    // 모든 학생 응답 조회
    const { data: responses, error } = await supabase
      .from('student_responses')
      .select('*')
      .eq('room_code', roomCode);
    
    if (error) throw error;
    
    // 병렬 분석 수행
    const analysisPromises = responses.map(async (response) => {
      const analysis = await ragAnalyzer.analyzeStudentResponse({
        see: response.see,
        think: response.think,
        wonder: response.wonder
      });
      
      // 개별 결과 저장
      await supabase
        .from('student_responses')
        .update({
          ai_analysis: analysis,
          analyzed_at: new Date().toISOString()
        })
        .eq('id', response.id);
      
      return {
        studentId: response.id,
        studentName: response.student_name,
        analysis: analysis
      };
    });
    
    const results = await Promise.all(analysisPromises);
    
    // 전체 분석 요약 생성
    const roomSummary = await ragAnalyzer.generateRoomSummary(results);
    
    res.json({
      success: true,
      individualAnalyses: results,
      roomSummary: roomSummary
    });
    
  } catch (error) {
    console.error('Room analysis error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

export default router;
```

## 📊 **5단계: 성능 최적화**

### **캐싱 및 배치 처리**
```javascript
// services/analysisCache.js
import Redis from 'redis';

class AnalysisCache {
  constructor() {
    this.redis = Redis.createClient({
      url: process.env.REDIS_URL
    });
    this.redis.connect();
  }

  // 분석 결과 캐싱
  async cacheAnalysis(responseId, analysis) {
    const key = `analysis:${responseId}`;
    await this.redis.setex(key, 3600, JSON.stringify(analysis)); // 1시간 캐시
  }

  // 캐시된 분석 결과 조회
  async getCachedAnalysis(responseId) {
    const key = `analysis:${responseId}`;
    const cached = await this.redis.get(key);
    return cached ? JSON.parse(cached) : null;
  }

  // 배치 분석 큐 관리
  async addToBatchQueue(roomCode, responseIds) {
    const queueKey = `batch:${roomCode}`;
    await this.redis.lpush(queueKey, ...responseIds);
  }

  async processBatchQueue(roomCode) {
    const queueKey = `batch:${roomCode}`;
    const responseIds = await this.redis.lrange(queueKey, 0, -1);
    await this.redis.del(queueKey);
    return responseIds;
  }
}
```

이런 구조로 RAG 시스템을 구축하면:

## 🎯 **장점**

1. **전문성**: 사고루틴 전문 지식을 체계적으로 활용
2. **정확성**: 벡터 검색을 통한 관련성 높은 컨텍스트 제공
3. **일관성**: 동일한 기준으로 모든 응답 분석
4. **확장성**: 새로운 사고루틴 추가 시 지식 베이스만 업데이트
5. **개인화**: 학생별 맞춤형 피드백 제공

## 🔧 **구현 시 고려사항**

1. **벡터 DB 초기화**: 최초 1회 지식 베이스 인덱싱 필요
2. **API 비용**: Gemini API 호출 최적화 필요
3. **응답 시간**: 실시간 분석 vs 배치 처리 선택
4. **정확도 검증**: 전문가 검토를 통한 분석 품질 확보

이렇게 구성하면 단순한 AI 분석이 아닌, 교육학적 근거를 바탕으로 한 전문적인 분석 시스템을 구축할 수 있습니다! 🚀

```plaintext
RAG 기반 분석 시스템
├── 1. 지식 베이스 구축 (Knowledge Base)
├── 2. 벡터 임베딩 및 저장 (Vector Store)
├── 3. 검색 시스템 (Retrieval)
├── 4. 컨텍스트 생성 (Context Generation)
└── 5. AI 분석 및 응답 생성 (Generation)
```

```javascript
// knowledgeBase.js
export const seeThinkWonderKnowledge = {
  // 기본 정보
  basic: {
    title: "See-Think-Wonder 사고루틴",
    purpose: "신중한 관찰, 해석적 사고, 탐구 정신 함양",
    developedBy: "Project Zero, Harvard Graduate School of Education",
    targetAge: "초등학생부터 성인까지",
    duration: "15-30분"
  },

  // 각 단계별 상세 가이드
  stages: {
    see: {
      title: "SEE (관찰하기)",
      objective: "객관적이고 구체적인 관찰 능력 개발",
      criteria: {
        specificity: "세부 사항을 얼마나 자세히 관찰했는가?",
        objectivity: "개인적 해석보다 사실적 관찰에 집중했는가?",
        diversity: "다양한 관점에서 관찰했는가?",
        accuracy: "실제 보이는 것을 정확히 기술했는가?"
      },
      excellentExamples: [
        "왼쪽 상단에 노란색 별들이 소용돌이 모양으로 배치되어 있다",
        "건물들은 어둡고 각진 모양이며, 창문에서 노란 빛이 새어나온다",
        "하늘의 3분의 2가 파란색과 노란색의 소용돌이로 채워져 있다"
      ],
      needsImprovementExamples: [
        "예쁘다", "멋있다", "좋다", // 감정적 표현
        "별이 있다", "집이 있다", // 너무 단순한 관찰
        "신비로워 보인다" // 해석이 섞인 관찰
      ],
      guidingQuestions: [
        "어떤 색깔들이 보이나요?",
        "어떤 모양들이 있나요?",
        "크기는 어떤가요?",
        "위치는 어디에 있나요?",
        "질감은 어떻게 보이나요?"
      ]
    },
    
    think: {
      title: "THINK (생각하기)",
      objective: "관찰을 바탕으로 한 해석적 사고력 개발",
      criteria: {
        connection: "관찰한 내용과 논리적으로 연결되었는가?",
        depth: "표면적 생각을 넘어 깊이 있게 사고했는가?",
        reasoning: "관찰을 바탕으로 합리적 추론을 했는가?",
        creativity: "독창적이고 다양한 관점을 제시했는가?"
      },
      excellentExamples: [
        "소용돌이치는 별들이 역동적인 느낌을 주어 화가의 감정 상태를 표현하는 것 같다",
        "어두운 마을과 밝은 하늘의 대비가 현실과 꿈의 경계를 나타내는 것 같다",
        "굵고 흐르는 붓터치가 바람의 움직임을 표현하려 한 것 같다"
      ],
      needsImprovementExamples: [
        "좋은 그림이다", // 평가적 표현
        "밤이다", // 단순한 사실 확인
        "예술가가 그렸다" // 당연한 추론
      ],
      guidingQuestions: [
        "왜 이런 색을 사용했을까요?",
        "작가가 무엇을 표현하려 했을까요?",
        "어떤 느낌이나 분위기를 주나요?",
        "다른 작품과 비교했을 때 어떤 특징이 있나요?"
      ]
    },
    
    wonder: {
      title: "WONDER (궁금해하기)",
      objective: "탐구 정신과 호기심 기반 학습 촉진",
      criteria: {
        investigatable: "실제로 탐구할 수 있는 질문인가?",
        specificity: "구체적이고 명확한 질문인가?",
        expandability: "더 깊은 학습으로 이어질 수 있는가?",
        creativity: "참신하고 흥미로운 질문인가?"
      },
      excellentExamples: [
        "왜 고흐는 밤하늘을 소용돌이 모양으로 그렸을까?",
        "이 그림을 그릴 때 고흐의 심리 상태는 어땠을까?",
        "실제 밤하늘과 다르게 표현한 이유는 무엇일까?",
        "다른 화가들은 밤하늘을 어떻게 그렸을까?"
      ],
      needsImprovementExamples: [
        "누가 그렸나요?", // 단순한 정보 질문
        "언제 그렸나요?", // 검색으로 쉽게 찾을 수 있는 질문
        "좋은 그림인가요?" // 주관적 판단 질문
      ],
      guidingQuestions: [
        "더 알고 싶은 것은 무엇인가요?",
        "어떤 부분이 가장 궁금한가요?",
        "다른 관점에서 보면 어떤 질문이 생기나요?",
        "이것과 관련된 다른 주제는 무엇일까요?"
      ]
    }
  },

  // 연령별 특성
  ageCharacteristics: {
    elementary: {
      strengths: ["직관적 관찰", "솔직한 표현", "무한한 호기심"],
      challenges: ["추상적 사고 어려움", "어휘력 한계", "집중력 부족"],
      adaptations: ["구체적 예시 제공", "단순한 언어 사용", "시각적 도구 활용"]
    }
  },

  // 평가 루브릭
  rubric: {
    excellent: {
      score: 5,
      see: "매우 구체적이고 다양한 관점에서 객관적으로 관찰",
      think: "관찰과 논리적으로 연결된 깊이 있고 창의적인 사고",
      wonder: "탐구 가능하고 확장성 있는 구체적이고 창의적인 질문"
    },
    good: {
      score: 4,
      see: "구체적이고 객관적인 관찰",
      think: "관찰과 연결된 적절한 수준의 사고",
      wonder: "탐구 가능한 구체적인 질문"
    },
    satisfactory: {
      score: 3,
      see: "기본적인 관찰 내용 포함",
      think: "관찰과 어느 정도 연결된 사고",
      wonder: "기본적인 질문 제시"
    },
    needsImprovement: {
      score: 2,
      see: "단순하거나 주관적인 관찰",
      think: "관찰과 연결성이 부족한 사고",
      wonder: "단순하거나 탐구하기 어려운 질문"
    },
    insufficient: {
      score: 1,
      see: "매우 단순하거나 부정확한 관찰",
      think: "관찰과 무관하거나 부적절한 사고",
      wonder: "질문이 없거나 부적절한 질문"
    }
  }
};
```

```javascript
// vectorStore.js
import { Pinecone } from '@pinecone-database/pinecone';
import { GoogleGenerativeAI } from '@google/generative-ai';

class VectorStore {
  constructor() {
    this.pinecone = new Pinecone({
      apiKey: process.env.PINECONE_API_KEY,
    });
    this.genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
    this.index = this.pinecone.index('thinking-routines');
  }

  // 텍스트를 벡터로 변환
  async createEmbedding(text) {
    try {
      const model = this.genAI.getGenerativeModel({ model: 'embedding-001' });
      const result = await model.embedContent(text);
      return result.embedding.values;
    } catch (error) {
      console.error('Embedding creation error:', error);
      throw error;
    }
  }

  // 지식 베이스를 벡터로 변환하여 저장
  async indexKnowledgeBase() {
    const documents = this.prepareDocuments();
    
    for (const doc of documents) {
      const embedding = await this.createEmbedding(doc.content);
      
      await this.index.upsert([{
        id: doc.id,
        values: embedding,
        metadata: {
          type: doc.type,
          stage: doc.stage,
          category: doc.category,
          content: doc.content,
          examples: doc.examples || [],
          criteria: doc.criteria || {}
        }
      }]);
    }
  }

  // 문서 준비
  prepareDocuments() {
    const documents = [];
    
    // SEE 단계 문서들
    documents.push({
      id: 'see-objectives',
      type: 'stage-guide',
      stage: 'see',
      category: 'objectives',
      content: `SEE 단계의 목적: ${seeThinkWonderKnowledge.stages.see.objective}`,
    });

    documents.push({
      id: 'see-criteria',
      type: 'evaluation-criteria',
      stage: 'see',
      category: 'criteria',
      content: `SEE 단계 평가 기준: ${JSON.stringify(seeThinkWonderKnowledge.stages.see.criteria)}`,
      criteria: seeThinkWonderKnowledge.stages.see.criteria
    });

    documents.push({
      id: 'see-examples',
      type: 'examples',
      stage: 'see',
      category: 'excellent',
      content: `SEE 단계 우수 사례: ${seeThinkWonderKnowledge.stages.see.excellentExamples.join(', ')}`,
      examples: seeThinkWonderKnowledge.stages.see.excellentExamples
    });

    // THINK, WONDER 단계도 동일하게 처리...
    
    return documents;
  }

  // 관련 문서 검색
  async searchRelevantDocs(query, stage = null, topK = 5) {
    const queryEmbedding = await this.createEmbedding(query);
    
    const searchRequest = {
      vector: queryEmbedding,
      topK: topK,
      includeMetadata: true
    };

    if (stage) {
      searchRequest.filter = { stage: { $eq: stage } };
    }

    const results = await this.index.query(searchRequest);
    return results.matches.map(match => ({
      score: match.score,
      content: match.metadata.content,
      type: match.metadata.type,
      stage: match.metadata.stage,
      category: match.metadata.category,
      examples: match.metadata.examples || [],
      criteria: match.metadata.criteria || {}
    }));
  }
}
```

```javascript
// ragAnalyzer.js
import { VectorStore } from './vectorStore.js';
import { GoogleGenerativeAI } from '@google/generative-ai';

class RAGAnalyzer {
  constructor() {
    this.vectorStore = new VectorStore();
    this.genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
  }

  async analyzeStudentResponse(studentResponse) {
    // 1. 각 단계별로 관련 문서 검색
    const seeContext = await this.vectorStore.searchRelevantDocs(
      studentResponse.see, 'see', 3
    );
    
    const thinkContext = await this.vectorStore.searchRelevantDocs(
      studentResponse.think, 'think', 3
    );
    
    const wonderContext = await this.vectorStore.searchRelevantDocs(
      studentResponse.wonder, 'wonder', 3
    );

    // 2. 전체적인 맥락 검색
    const overallQuery = `${studentResponse.see} ${studentResponse.think} ${studentResponse.wonder}`;
    const overallContext = await this.vectorStore.searchRelevantDocs(
      overallQuery, null, 5
    );

    // 3. 컨텍스트 생성
    const context = this.buildContext(seeContext, thinkContext, wonderContext, overallContext);

    // 4. AI 분석 수행
    return await this.performAnalysis(studentResponse, context);
  }

  buildContext(seeContext, thinkContext, wonderContext, overallContext) {
    return {
      seeGuidelines: seeContext.map(doc => ({
        type: doc.type,
        content: doc.content,
        examples: doc.examples,
        criteria: doc.criteria
      })),
      thinkGuidelines: thinkContext.map(doc => ({
        type: doc.type,
        content: doc.content,
        examples: doc.examples,
        criteria: doc.criteria
      })),
      wonderGuidelines: wonderContext.map(doc => ({
        type: doc.type,
        content: doc.content,
        examples: doc.examples,
        criteria: doc.criteria
      })),
      overallGuidelines: overallContext.map(doc => ({
        type: doc.type,
        content: doc.content,
        stage: doc.stage
      }))
    };
  }

  async performAnalysis(studentResponse, context) {
    const model = this.genAI.getGenerativeModel({ model: 'gemini-pro' });
    
    const prompt = this.buildAnalysisPrompt(studentResponse, context);
    
    try {
      const result = await model.generateContent(prompt);
      const response = await result.response;
      const analysisText = response.text();
      
      // JSON 파싱 시도
      const analysis = JSON.parse(analysisText);
      
      // 분석 결과 후처리
      return this.postProcessAnalysis(analysis, context);
      
    } catch (error) {
      console.error('Analysis error:', error);
      return this.getDefaultAnalysis();
    }
  }

  buildAnalysisPrompt(studentResponse, context) {
    return `
당신은 See-Think-Wonder 사고루틴 전문 분석가입니다.
다음 컨텍스트를 참고하여 학생의 응답을 분석해주세요.

## 컨텍스트 정보

### SEE 단계 가이드라인:
${context.seeGuidelines.map(guide => `
- ${guide.content}
- 평가 기준: ${JSON.stringify(guide.criteria)}
- 우수 사례: ${guide.examples.join(', ')}
`).join('\n')}

### THINK 단계 가이드라인:
${context.thinkGuidelines.map(guide => `
- ${guide.content}
- 평가 기준: ${JSON.stringify(guide.criteria)}
- 우수 사례: ${guide.examples.join(', ')}
`).join('\n')}

### WONDER 단계 가이드라인:
${context.wonderGuidelines.map(guide => `
- ${guide.content}
- 평가 기준: ${JSON.stringify(guide.criteria)}
- 우수 사례: ${guide.examples.join(', ')}
`).join('\n')}

## 학생 응답
SEE: ${studentResponse.see}
THINK: ${studentResponse.think}
WONDER: ${studentResponse.wonder}

## 분석 요청
위의 전문 가이드라인을 바탕으로 학생의 응답을 분석하고, 
다음 JSON 형식으로 결과를 제공해주세요:

{
  "overallScore": 5,
  "overallComment": "전체적인 평가 및 격려 메시지",
  "seeAnalysis": {
    "score": 4,
    "strengths": ["구체적인 관찰", "다양한 요소 포함"],
    "improvements": ["객관성 향상 필요"],
    "feedback": "학생 맞춤형 피드백",
    "matchedCriteria": ["specificity", "diversity"],
    "suggestedExamples": ["개선을 위한 예시"]
  },
  "thinkAnalysis": {
    "score": 4,
    "strengths": ["논리적 연결", "창의적 사고"],
    "improvements": ["더 깊은 분석 필요"],
    "feedback": "학생 맞춤형 피드백",
    "matchedCriteria": ["connection", "creativity"],
    "suggestedExamples": ["개선을 위한 예시"]
  },
  "wonderAnalysis": {
    "score": 3,
    "strengths": ["구체적 질문"],
    "improvements": ["탐구 가능성 향상"],
    "feedback": "학생 맞춤형 피드백",
    "matchedCriteria": ["specificity"],
    "suggestedExamples": ["개선을 위한 예시"]
  },
  "encouragement": "개인화된 격려 메시지",
  "nextSteps": ["구체적인 다음 단계 제안"],
  "teacherNotes": "교사를 위한 추가 지도 방향"
}

분석 시 주의사항:
1. 초등학생 수준에 맞는 언어와 피드백 사용
2. 긍정적이고 격려하는 톤 유지
3. 구체적이고 실행 가능한 개선 제안
4. 학생의 노력과 시도를 인정하고 칭찬
5. 각 단계별 전문 기준에 따른 정확한 평가
`;
  }

  postProcessAnalysis(analysis, context) {
    // 분석 결과에 추가 정보 보강
    return {
      ...analysis,
      analysisTimestamp: new Date().toISOString(),
      contextUsed: {
        seeDocuments: context.seeGuidelines.length,
        thinkDocuments: context.thinkGuidelines.length,
        wonderDocuments: context.wonderGuidelines.length,
        overallDocuments: context.overallGuidelines.length
      },
      confidence: this.calculateConfidence(analysis),
      recommendations: this.generateRecommendations(analysis)
    };
  }

  calculateConfidence(analysis) {
    // 분석 결과의 신뢰도 계산
    const scores = [
      analysis.seeAnalysis.score,
      analysis.thinkAnalysis.score,
      analysis.wonderAnalysis.score
    ];
    
    const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
    const variance = scores.reduce((acc, score) => acc + Math.pow(score - avgScore, 2), 0) / scores.length;
    
    // 점수가 일관되고 높을수록 신뢰도 높음
    return Math.max(0, Math.min(1, (avgScore / 5) * (1 - variance / 5)));
  }

  generateRecommendations(analysis) {
    const recommendations = [];
    
    // 각 단계별 점수에 따른 추천 활동
    if (analysis.seeAnalysis.score < 3) {
      recommendations.push({
        type: 'observation',
        activity: '관찰 게임을 통한 세부 사항 찾기 연습',
        priority: 'high'
      });
    }
    
    if (analysis.thinkAnalysis.score < 3) {
      recommendations.push({
        type: 'thinking',
        activity: '왜? 어떻게? 질문을 통한 사고 확장 연습',
        priority: 'medium'
      });
    }
    
    if (analysis.wonderAnalysis.score < 3) {
      recommendations.push({
        type: 'inquiry',
        activity: '질문 만들기 게임을 통한 탐구 정신 기르기',
        priority: 'medium'
      });
    }
    
    return recommendations;
  }

  getDefaultAnalysis() {
    return {
      overallScore: 3,
      overallComment: "좋은 시도였어요! 각 단계를 모두 완성했네요.",
      seeAnalysis: {
        score: 3,
        strengths: ["관찰을 시도했어요"],
        improvements: ["더 자세히 관찰해보세요"],
        feedback: "다음에는 색깔, 모양, 크기 등을 더 구체적으로 적어보세요.",
        matchedCriteria: [],
        suggestedExamples: []
      },
      thinkAnalysis: {
        score: 3,
        strengths: ["생각을 표현했어요"],
        improvements: ["관찰한 내용과 연결해보세요"],
        feedback: "관찰한 것을 바탕으로 왜 그럴까 생각해보세요.",
        matchedCriteria: [],
        suggestedExamples: []
      },
      wonderAnalysis: {
        score: 3,
        strengths: ["궁금한 점을 생각했어요"],
        improvements: ["더 구체적인 질문을 만들어보세요"],
        feedback: "궁금한 점을 더 자세히 질문으로 만들어보세요.",
        matchedCriteria: [],
        suggestedExamples: []
      },
      encouragement: "계속 노력하면 더 잘할 수 있을 거예요!",
      nextSteps: ["다음에는 더 자세히 관찰하고 생각해보세요"],
      teacherNotes: "기본적인 참여는 이루어졌으나 각 단계별 심화 지도가 필요합니다."
    };
  }
}

export { RAGAnalyzer };
```

```javascript
// routes/analysis.js
import express from 'express';
import { RAGAnalyzer } from '../services/ragAnalyzer.js';
import { supabase } from '../lib/supabase.js';

const router = express.Router();
const ragAnalyzer = new RAGAnalyzer();

// 개별 학생 응답 분석
router.post('/analyze/:responseId', async (req, res) => {
  try {
    const { responseId } = req.params;
    
    // 학생 응답 조회
    const { data: response, error } = await supabase
      .from('student_responses')
      .select('*')
      .eq('id', responseId)
      .single();
    
    if (error) throw error;
    
    // RAG 분석 수행
    const analysis = await ragAnalyzer.analyzeStudentResponse({
      see: response.see,
      think: response.think,
      wonder: response.wonder
    });
    
    // 분석 결과 저장
    const { error: updateError } = await supabase
      .from('student_responses')
      .update({
        ai_analysis: analysis,
        analyzed_at: new Date().toISOString()
      })
      .eq('id', responseId);
    
    if (updateError) throw updateError;
    
    res.json({
      success: true,
      analysis: analysis
    });
    
  } catch (error) {
    console.error('Analysis error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// 전체 활동방 분석
router.post('/analyze-room/:roomCode', async (req, res) => {
  try {
    const { roomCode } = req.params;
    
    // 모든 학생 응답 조회
    const { data: responses, error } = await supabase
      .from('student_responses')
      .select('*')
      .eq('room_code', roomCode);
    
    if (error) throw error;
    
    // 병렬 분석 수행
    const analysisPromises = responses.map(async (response) => {
      const analysis = await ragAnalyzer.analyzeStudentResponse({
        see: response.see,
        think: response.think,
        wonder: response.wonder
      });
      
      // 개별 결과 저장
      await supabase
        .from('student_responses')
        .update({
          ai_analysis: analysis,
          analyzed_at: new Date().toISOString()
        })
        .eq('id', response.id);
      
      return {
        studentId: response.id,
        studentName: response.student_name,
        analysis: analysis
      };
    });
    
    const results = await Promise.all(analysisPromises);
    
    // 전체 분석 요약 생성
    const roomSummary = await ragAnalyzer.generateRoomSummary(results);
    
    res.json({
      success: true,
      individualAnalyses: results,
      roomSummary: roomSummary
    });
    
  } catch (error) {
    console.error('Room analysis error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

export default router;
```

```javascript
// services/analysisCache.js
import Redis from 'redis';

class AnalysisCache {
  constructor() {
    this.redis = Redis.createClient({
      url: process.env.REDIS_URL
    });
    this.redis.connect();
  }

  // 분석 결과 캐싱
  async cacheAnalysis(responseId, analysis) {
    const key = `analysis:${responseId}`;
    await this.redis.setex(key, 3600, JSON.stringify(analysis)); // 1시간 캐시
  }

  // 캐시된 분석 결과 조회
  async getCachedAnalysis(responseId) {
    const key = `analysis:${responseId}`;
    const cached = await this.redis.get(key);
    return cached ? JSON.parse(cached) : null;
  }

  // 배치 분석 큐 관리
  async addToBatchQueue(roomCode, responseIds) {
    const queueKey = `batch:${roomCode}`;
    await this.redis.lpush(queueKey, ...responseIds);
  }

  async processBatchQueue(roomCode) {
    const queueKey = `batch:${roomCode}`;
    const responseIds = await this.redis.lrange(queueKey, 0, -1);
    await this.redis.del(queueKey);
    return responseIds;
  }
}
```

---

**User**

그럼 처음에 지식 베이스 구축할 때 내가 어떤걸해야하지? 각 사고루틴에 대한 설명이 있는 pdf문서 같은걸 주면 효과적인가?

---

**Cursor**

좋은 질문이네요! 지식 베이스 구축을 위한 효과적인 방법을 단계별로 알려드리겠습니다.

## 📚 **지식 베이스 구축 방법**

### **1단계: 문서 수집 및 준비**

가장 효과적인 방법은 **구조화된 문서**를 제공하는 것입니다:

#### **📄 PDF 문서 활용 (추천)**
```
필요한 문서들:
├── See-Think-Wonder 공식 가이드 (Project Zero)
├── 사고루틴 활용 매뉴얼
├── 교육과정 연계 자료
├── 평가 루브릭 문서
└── 실제 수업 사례집
```

#### **📝 직접 작성 (더 효과적)**
하지만 더 좋은 방법은 **체계적으로 정리된 문서**를 직접 만드는 것입니다:

```markdown
# See-Think-Wonder 전문 가이드

## 1. 기본 정보
- 개발기관: Harvard Project Zero
- 목적: 관찰력, 사고력, 탐구력 향상
- 대상: 초등학생~성인
- 소요시간: 15-30분

## 2. 각 단계별 상세 가이드

### SEE (관찰하기)
**목적**: 객관적이고 구체적인 관찰 능력 개발

**평가 기준**:
- 구체성: 세부사항을 얼마나 자세히 관찰했는가?
- 객관성: 해석보다 사실 기술에 집중했는가?
- 다양성: 여러 관점에서 관찰했는가?
- 정확성: 실제 보이는 것을 정확히 기술했는가?

**우수 사례**:
- "왼쪽 상단에 노란색 별들이 소용돌이 모양으로 배치되어 있다"
- "건물들은 어둡고 각진 모양이며, 창문에서 노란 빛이 새어나온다"

**개선 필요 사례**:
- "예쁘다", "멋있다" (감정적 표현)
- "별이 있다" (너무 단순)
- "신비로워 보인다" (해석이 섞임)

**연령별 특성**:
- 초등 저학년: 단순 나열 경향, 감정 표현 많음
- 초등 고학년: 구체성 향상, 여전히 해석 섞임
- 중학생: 객관성 이해 시작, 어휘력 확장

### THINK (생각하기)
**목적**: 관찰을 바탕으로 한 해석적 사고력 개발
... (계속)
```

### **2단계: 자동 문서 처리 시스템 구축**

#### **PDF 파싱 시스템**
```javascript
// documentProcessor.js
import { PDFExtract } from 'pdf.js-extract';
import { RecursiveCharacterTextSplitter } from 'langchain/text_splitter';

class DocumentProcessor {
  constructor() {
    this.pdfExtract = new PDFExtract();
    this.textSplitter = new RecursiveCharacterTextSplitter({
      chunkSize: 1000,
      chunkOverlap: 200,
    });
  }

  // PDF 파일 처리
  async processPDF(filePath) {
    try {
      const data = await this.pdfExtract.extract(filePath);
      
      // 텍스트 추출
      const fullText = data.pages
        .map(page => page.content
          .map(item => item.str)
          .join(' ')
        )
        .join('\n');

      // 청크 단위로 분할
      const chunks = await this.textSplitter.splitText(fullText);
      
      // 메타데이터 추가
      return chunks.map((chunk, index) => ({
        id: `pdf-chunk-${index}`,
        content: chunk,
        source: filePath,
        type: 'pdf',
        chunkIndex: index
      }));
      
    } catch (error) {
      console.error('PDF processing error:', error);
      throw error;
    }
  }

  // 마크다운 파일 처리
  async processMarkdown(filePath) {
    const fs = require('fs').promises;
    const content = await fs.readFile(filePath, 'utf8');
    
    // 섹션별로 분할
    const sections = this.parseMarkdownSections(content);
    
    return sections.map((section, index) => ({
      id: `md-section-${index}`,
      content: section.content,
      title: section.title,
      level: section.level,
      source: filePath,
      type: 'markdown'
    }));
  }

  parseMarkdownSections(content) {
    const sections = [];
    const lines = content.split('\n');
    let currentSection = { title: '', content: '', level: 0 };
    
    for (const line of lines) {
      const headerMatch = line.match(/^(#{1,6})\s+(.+)$/);
      
      if (headerMatch) {
        // 이전 섹션 저장
        if (currentSection.content.trim()) {
          sections.push({ ...currentSection });
        }
        
        // 새 섹션 시작
        currentSection = {
          title: headerMatch[2],
          content: '',
          level: headerMatch[1].length
        };
      } else {
        currentSection.content += line + '\n';
      }
    }
    
    // 마지막 섹션 저장
    if (currentSection.content.trim()) {
      sections.push(currentSection);
    }
    
    return sections;
  }
}
```

### **3단계: 지식 베이스 초기화 스크립트**

#### **초기화 명령어**
```javascript
// scripts/initializeKnowledgeBase.js
import { DocumentProcessor } from '../services/documentProcessor.js';
import { VectorStore } from '../services/vectorStore.js';
import path from 'path';

class KnowledgeBaseInitializer {
  constructor() {
    this.documentProcessor = new DocumentProcessor();
    this.vectorStore = new VectorStore();
  }

  async initialize() {
    console.log('🚀 지식 베이스 초기화 시작...');
    
    try {
      // 1. 문서 디렉토리 스캔
      const documentsPath = path.join(process.cwd(), 'knowledge-base');
      const documents = await this.scanDocuments(documentsPath);
      
      console.log(`📄 발견된 문서: ${documents.length}개`);
      
      // 2. 각 문서 처리
      let allChunks = [];
      for (const doc of documents) {
        console.log(`처리 중: ${doc.name}`);
        
        if (doc.type === 'pdf') {
          const chunks = await this.documentProcessor.processPDF(doc.path);
          allChunks = allChunks.concat(chunks);
        } else if (doc.type === 'markdown') {
          const chunks = await this.documentProcessor.processMarkdown(doc.path);
          allChunks = allChunks.concat(chunks);
        }
      }
      
      console.log(`📝 생성된 청크: ${allChunks.length}개`);
      
      // 3. 벡터 DB에 저장
      await this.vectorStore.indexDocuments(allChunks);
      
      console.log('✅ 지식 베이스 초기화 완료!');
      
    } catch (error) {
      console.error('❌ 초기화 실패:', error);
      throw error;
    }
  }

  async scanDocuments(dirPath) {
    const fs = require('fs').promises;
    const files = await fs.readdir(dirPath);
    
    return files
      .filter(file => file.endsWith('.pdf') || file.endsWith('.md'))
      .map(file => ({
        name: file,
        path: path.join(dirPath, file),
        type: file.endsWith('.pdf') ? 'pdf' : 'markdown'
      }));
  }
}

// 실행
const initializer = new KnowledgeBaseInitializer();
initializer.initialize();
```

### **4단계: 권장 문서 구조**

#### **📁 디렉토리 구조**
```
knowledge-base/
├── official-guides/
│   ├── see-think-wonder-official.pdf
│   ├── project-zero-guide.pdf
│   └── harvard-thinking-routines.pdf
├── evaluation-rubrics/
│   ├── see-think-wonder-rubric.md
│   ├── age-appropriate-criteria.md
│   └── scoring-guidelines.md
├── examples/
│   ├── excellent-examples.md
│   ├── common-mistakes.md
│   └── improvement-cases.md
├── curriculum-alignment/
│   ├── korean-curriculum-2022.md
│   ├── ib-pyp-connection.md
│   └── subject-integration.md
└── implementation/
    ├── classroom-tips.md
    ├── technology-integration.md
    └── assessment-strategies.md
```

#### **📝 핵심 문서 템플릿**

**see-think-wonder-rubric.md**
```markdown
# See-Think-Wonder 평가 루브릭

## 전체 평가 기준

### 5점 (탁월함)
**SEE**: 매우 구체적이고 다양한 관점에서 객관적 관찰
- 예시: "왼쪽 상단의 노란색 별들이 시계방향으로 소용돌이치며..."
- 특징: 색상, 형태, 위치, 크기, 질감 등 다차원적 관찰

**THINK**: 관찰과 논리적으로 연결된 깊이 있고 창의적인 사고
- 예시: "소용돌이치는 별들이 화가의 내면 감정을 표현하는 것 같다"
- 특징: 인과관계, 상징적 의미, 감정 해석 등 다층적 사고

**WONDER**: 탐구 가능하고 확장성 있는 구체적이고 창의적인 질문
- 예시: "고흐는 왜 실제와 다르게 하늘을 소용돌이로 표현했을까?"
- 특징: 구체적, 탐구 가능, 학습 확장성

### 4점 (우수함)
... (계속)
```

### **5단계: 실행 가이드**

#### **🎯 당신이 해야 할 일**

1. **문서 수집 (1-2일)**
   ```bash
   # 프로젝트 루트에 knowledge-base 폴더 생성
   mkdir knowledge-base
   cd knowledge-base
   
   # 하위 폴더 생성
   mkdir official-guides evaluation-rubrics examples curriculum-alignment implementation
   ```

2. **핵심 문서 작성 (3-5일)**
   - `see-think-wonder-complete-guide.md` (가장 중요!)
   - `evaluation-rubric-detailed.md`
   - `excellent-examples-by-age.md`
   - `common-mistakes-and-solutions.md`

3. **초기화 실행 (1일)**
   ```bash
   # 지식 베이스 초기화
   npm run init-knowledge-base
   
   # 테스트 실행
   npm run test-analysis
   ```

#### **📋 문서 작성 체크리스트**

- [ ] See-Think-Wonder 기본 개념 및 목적
- [ ] 각 단계별 상세 평가 기준
- [ ] 연령별 특성 및 적응 방법
- [ ] 우수 사례 100개 이상
- [ ] 개선 필요 사례 50개 이상
- [ ] 교사 가이드 및 팁
- [ ] 기술 통합 방법
- [ ] 평가 및 피드백 전략

#### **🚀 효율적인 방법**

**Option 1: 기존 PDF 활용**
- 기존 PDF 문서들을 `knowledge-base/official-guides/`에 넣기
- 자동 파싱 후 수동 검토 및 보완

**Option 2: 구조화된 문서 직접 작성 (추천)**
- 위의 템플릿을 기반으로 체계적으로 작성
- 더 정확하고 일관된 분석 결과 보장

**Option 3: 혼합 방식**
- 기존 PDF로 기본 지식 구축
- 핵심 평가 기준은 직접 작성

### **6단계: 품질 검증**

```javascript
// 지식 베이스 품질 테스트
const testQueries = [
  "초등학생이 '예쁘다'라고만 답했을 때 어떻게 평가해야 하나?",
  "관찰과 생각이 연결되지 않은 경우 피드백은?",
  "우수한 Wonder 질문의 특징은?",
  "연령별 평가 기준 차이는?"
];

// 각 질문에 대해 관련 문서가 잘 검색되는지 확인
```

이렇게 준비하시면 매우 효과적인 RAG 시스템을 구축할 수 있습니다! 

**가장 중요한 것은 체계적으로 정리된 평가 기준과 풍부한 예시들**입니다. 혹시 문서 작성에 도움이 필요하시면 템플릿을 더 자세히 만들어드릴 수 있습니다! 🎯

```plaintext
필요한 문서들:
├── See-Think-Wonder 공식 가이드 (Project Zero)
├── 사고루틴 활용 매뉴얼
├── 교육과정 연계 자료
├── 평가 루브릭 문서
└── 실제 수업 사례집
```

```markdown
# See-Think-Wonder 전문 가이드

## 1. 기본 정보
- 개발기관: Harvard Project Zero
- 목적: 관찰력, 사고력, 탐구력 향상
- 대상: 초등학생~성인
- 소요시간: 15-30분

## 2. 각 단계별 상세 가이드

### SEE (관찰하기)
**목적**: 객관적이고 구체적인 관찰 능력 개발

**평가 기준**:
- 구체성: 세부사항을 얼마나 자세히 관찰했는가?
- 객관성: 해석보다 사실 기술에 집중했는가?
- 다양성: 여러 관점에서 관찰했는가?
- 정확성: 실제 보이는 것을 정확히 기술했는가?

**우수 사례**:
- "왼쪽 상단에 노란색 별들이 소용돌이 모양으로 배치되어 있다"
- "건물들은 어둡고 각진 모양이며, 창문에서 노란 빛이 새어나온다"

**개선 필요 사례**:
- "예쁘다", "멋있다" (감정적 표현)
- "별이 있다" (너무 단순)
- "신비로워 보인다" (해석이 섞임)

**연령별 특성**:
- 초등 저학년: 단순 나열 경향, 감정 표현 많음
- 초등 고학년: 구체성 향상, 여전히 해석 섞임
- 중학생: 객관성 이해 시작, 어휘력 확장

### THINK (생각하기)
**목적**: 관찰을 바탕으로 한 해석적 사고력 개발
... (계속)
```

```javascript
// documentProcessor.js
import { PDFExtract } from 'pdf.js-extract';
import { RecursiveCharacterTextSplitter } from 'langchain/text_splitter';

class DocumentProcessor {
  constructor() {
    this.pdfExtract = new PDFExtract();
    this.textSplitter = new RecursiveCharacterTextSplitter({
      chunkSize: 1000,
      chunkOverlap: 200,
    });
  }

  // PDF 파일 처리
  async processPDF(filePath) {
    try {
      const data = await this.pdfExtract.extract(filePath);
      
      // 텍스트 추출
      const fullText = data.pages
        .map(page => page.content
          .map(item => item.str)
          .join(' ')
        )
        .join('\n');

      // 청크 단위로 분할
      const chunks = await this.textSplitter.splitText(fullText);
      
      // 메타데이터 추가
      return chunks.map((chunk, index) => ({
        id: `pdf-chunk-${index}`,
        content: chunk,
        source: filePath,
        type: 'pdf',
        chunkIndex: index
      }));
      
    } catch (error) {
      console.error('PDF processing error:', error);
      throw error;
    }
  }

  // 마크다운 파일 처리
  async processMarkdown(filePath) {
    const fs = require('fs').promises;
    const content = await fs.readFile(filePath, 'utf8');
    
    // 섹션별로 분할
    const sections = this.parseMarkdownSections(content);
    
    return sections.map((section, index) => ({
      id: `md-section-${index}`,
      content: section.content,
      title: section.title,
      level: section.level,
      source: filePath,
      type: 'markdown'
    }));
  }

  parseMarkdownSections(content) {
    const sections = [];
    const lines = content.split('\n');
    let currentSection = { title: '', content: '', level: 0 };
    
    for (const line of lines) {
      const headerMatch = line.match(/^(#{1,6})\s+(.+)$/);
      
      if (headerMatch) {
        // 이전 섹션 저장
        if (currentSection.content.trim()) {
          sections.push({ ...currentSection });
        }
        
        // 새 섹션 시작
        currentSection = {
          title: headerMatch[2],
          content: '',
          level: headerMatch[1].length
        };
      } else {
        currentSection.content += line + '\n';
      }
    }
    
    // 마지막 섹션 저장
    if (currentSection.content.trim()) {
      sections.push(currentSection);
    }
    
    return sections;
  }
}
```

```javascript
// scripts/initializeKnowledgeBase.js
import { DocumentProcessor } from '../services/documentProcessor.js';
import { VectorStore } from '../services/vectorStore.js';
import path from 'path';

class KnowledgeBaseInitializer {
  constructor() {
    this.documentProcessor = new DocumentProcessor();
    this.vectorStore = new VectorStore();
  }

  async initialize() {
    console.log('🚀 지식 베이스 초기화 시작...');
    
    try {
      // 1. 문서 디렉토리 스캔
      const documentsPath = path.join(process.cwd(), 'knowledge-base');
      const documents = await this.scanDocuments(documentsPath);
      
      console.log(`📄 발견된 문서: ${documents.length}개`);
      
      // 2. 각 문서 처리
      let allChunks = [];
      for (const doc of documents) {
        console.log(`처리 중: ${doc.name}`);
        
        if (doc.type === 'pdf') {
          const chunks = await this.documentProcessor.processPDF(doc.path);
          allChunks = allChunks.concat(chunks);
        } else if (doc.type === 'markdown') {
          const chunks = await this.documentProcessor.processMarkdown(doc.path);
          allChunks = allChunks.concat(chunks);
        }
      }
      
      console.log(`📝 생성된 청크: ${allChunks.length}개`);
      
      // 3. 벡터 DB에 저장
      await this.vectorStore.indexDocuments(allChunks);
      
      console.log('✅ 지식 베이스 초기화 완료!');
      
    } catch (error) {
      console.error('❌ 초기화 실패:', error);
      throw error;
    }
  }

  async scanDocuments(dirPath) {
    const fs = require('fs').promises;
    const files = await fs.readdir(dirPath);
    
    return files
      .filter(file => file.endsWith('.pdf') || file.endsWith('.md'))
      .map(file => ({
        name: file,
        path: path.join(dirPath, file),
        type: file.endsWith('.pdf') ? 'pdf' : 'markdown'
      }));
  }
}

// 실행
const initializer = new KnowledgeBaseInitializer();
initializer.initialize();
```

```plaintext
knowledge-base/
├── official-guides/
│   ├── see-think-wonder-official.pdf
│   ├── project-zero-guide.pdf
│   └── harvard-thinking-routines.pdf
├── evaluation-rubrics/
│   ├── see-think-wonder-rubric.md
│   ├── age-appropriate-criteria.md
│   └── scoring-guidelines.md
├── examples/
│   ├── excellent-examples.md
│   ├── common-mistakes.md
│   └── improvement-cases.md
├── curriculum-alignment/
│   ├── korean-curriculum-2022.md
│   ├── ib-pyp-connection.md
│   └── subject-integration.md
└── implementation/
    ├── classroom-tips.md
    ├── technology-integration.md
    └── assessment-strategies.md
```

```markdown
# See-Think-Wonder 평가 루브릭

## 전체 평가 기준

### 5점 (탁월함)
**SEE**: 매우 구체적이고 다양한 관점에서 객관적 관찰
- 예시: "왼쪽 상단의 노란색 별들이 시계방향으로 소용돌이치며..."
- 특징: 색상, 형태, 위치, 크기, 질감 등 다차원적 관찰

**THINK**: 관찰과 논리적으로 연결된 깊이 있고 창의적인 사고
- 예시: "소용돌이치는 별들이 화가의 내면 감정을 표현하는 것 같다"
- 특징: 인과관계, 상징적 의미, 감정 해석 등 다층적 사고

**WONDER**: 탐구 가능하고 확장성 있는 구체적이고 창의적인 질문
- 예시: "고흐는 왜 실제와 다르게 하늘을 소용돌이로 표현했을까?"
- 특징: 구체적, 탐구 가능, 학습 확장성

### 4점 (우수함)
... (계속)
```

```shellscript
   # 프로젝트 루트에 knowledge-base 폴더 생성
   mkdir knowledge-base
   cd knowledge-base
   
   # 하위 폴더 생성
   mkdir official-guides evaluation-rubrics examples curriculum-alignment implementation
```

```shellscript
   # 지식 베이스 초기화
   npm run init-knowledge-base
   
   # 테스트 실행
   npm run test-analysis
```

```javascript
// 지식 베이스 품질 테스트
const testQueries = [
  "초등학생이 '예쁘다'라고만 답했을 때 어떻게 평가해야 하나?",
  "관찰과 생각이 연결되지 않은 경우 피드백은?",
  "우수한 Wonder 질문의 특징은?",
  "연령별 평가 기준 차이는?"
];

// 각 질문에 대해 관련 문서가 잘 검색되는지 확인
```

---

**User**

아직은 내가 너가 말한 것처럼 다양한 문서나 사례나 평가 기준이 없는데 이거는 지금 만드는 웹앱을 활용해서 다양한 사례나 내용들이 데이터로 쌓이면 이걸 지식 구조로 입력해서 퀄리티를 좋아지게 하는 선순환 구조로 만들려고 하는데 괜찮을까?

---

**Cursor**

정말 훌륭한 아이디어네요! 🎯 **데이터 기반 선순환 구조**를 만드는 것은 매우 현명한 접근입니다. 실제로 이런 방식이 더 실용적이고 효과적일 수 있어요.

## 🔄 **선순환 구조 설계**

### **1단계: 최소 지식 베이스로 시작**

#### **초기 시드 데이터 (간단하게)**
```javascript
// initialKnowledgeBase.js
const seedKnowledge = {
  seeThinkWonder: {
    basic: {
      see: {
        purpose: "구체적이고 객관적인 관찰",
        goodIndicators: ["구체적 묘사", "객관적 표현", "다양한 요소"],
        badIndicators: ["감정적 표현", "너무 단순", "주관적 해석"]
      },
      think: {
        purpose: "관찰을 바탕으로 한 해석적 사고",
        goodIndicators: ["논리적 연결", "창의적 해석", "깊이 있는 사고"],
        badIndicators: ["관찰과 무관", "단순한 반복", "근거 부족"]
      },
      wonder: {
        purpose: "탐구 가능한 질문 생성",
        goodIndicators: ["구체적 질문", "탐구 가능", "확장성"],
        badIndicators: ["단순한 정보", "주관적 판단", "탐구 불가"]
      }
    }
  }
};
```

### **2단계: 데이터 수집 및 분석 시스템**

#### **학습 데이터 수집**
```javascript
// dataCollector.js
class LearningDataCollector {
  constructor() {
    this.supabase = supabase;
  }

  // 교사 피드백 수집
  async collectTeacherFeedback(responseId, teacherFeedback, aiAnalysis) {
    const learningData = {
      student_response: await this.getStudentResponse(responseId),
      ai_analysis: aiAnalysis,
      teacher_feedback: teacherFeedback,
      teacher_agreement: {
        see_score_diff: Math.abs(teacherFeedback.seeScore - aiAnalysis.seeAnalysis.score),
        think_score_diff: Math.abs(teacherFeedback.thinkScore - aiAnalysis.thinkAnalysis.score),
        wonder_score_diff: Math.abs(teacherFeedback.wonderScore - aiAnalysis.wonderAnalysis.score)
      },
      feedback_quality: teacherFeedback.quality, // 교사가 AI 분석의 품질 평가
      timestamp: new Date().toISOString()
    };

    // 학습 데이터 저장
    await this.supabase
      .from('learning_data')
      .insert(learningData);

    return learningData;
  }

  // 우수 사례 자동 식별
  async identifyExcellentCases() {
    const { data: cases } = await this.supabase
      .from('learning_data')
      .select('*')
      .gte('teacher_feedback.overall_score', 4)
      .lte('teacher_agreement.see_score_diff', 1)
      .lte('teacher_agreement.think_score_diff', 1)
      .lte('teacher_agreement.wonder_score_diff', 1);

    return cases;
  }

  // 개선 필요 패턴 분석
  async analyzeImprovementPatterns() {
    const { data: patterns } = await this.supabase
      .from('learning_data')
      .select('*')
      .or('teacher_agreement.see_score_diff.gte.2,teacher_agreement.think_score_diff.gte.2,teacher_agreement.wonder_score_diff.gte.2');

    return this.categorizePatterns(patterns);
  }
}
```

### **3단계: 자동 지식 베이스 업데이트**

#### **지식 베이스 진화 시스템**
```javascript
// knowledgeEvolution.js
class KnowledgeEvolution {
  constructor() {
    this.vectorStore = new VectorStore();
    this.dataCollector = new LearningDataCollector();
  }

  // 주기적 지식 베이스 업데이트 (예: 매주)
  async evolveKnowledgeBase() {
    console.log('🔄 지식 베이스 진화 시작...');

    // 1. 새로운 우수 사례 수집
    const excellentCases = await this.dataCollector.identifyExcellentCases();
    
    // 2. 개선 패턴 분석
    const improvementPatterns = await this.dataCollector.analyzeImprovementPatterns();
    
    // 3. 새로운 지식 생성
    const newKnowledge = await this.generateNewKnowledge(excellentCases, improvementPatterns);
    
    // 4. 벡터 DB 업데이트
    await this.updateVectorStore(newKnowledge);
    
    console.log('✅ 지식 베이스 진화 완료!');
  }

  async generateNewKnowledge(excellentCases, improvementPatterns) {
    const newKnowledge = [];

    // 우수 사례에서 패턴 추출
    for (const case_ of excellentCases) {
      const pattern = await this.extractPattern(case_);
      newKnowledge.push({
        type: 'excellent_pattern',
        stage: pattern.stage,
        content: pattern.description,
        examples: [case_.student_response],
        confidence: this.calculateConfidence(case_)
      });
    }

    // 개선 패턴에서 가이드라인 생성
    for (const pattern of improvementPatterns) {
      newKnowledge.push({
        type: 'improvement_guide',
        stage: pattern.stage,
        content: pattern.guidance,
        commonMistakes: pattern.mistakes,
        confidence: pattern.frequency
      });
    }

    return newKnowledge;
  }

  async extractPattern(case_) {
    // Gemini API로 패턴 추출
    const prompt = `
다음 우수 사례에서 패턴을 추출해주세요:

학생 응답: ${JSON.stringify(case_.student_response)}
교사 평가: ${JSON.stringify(case_.teacher_feedback)}

이 사례가 우수한 이유와 다른 학생들이 참고할 수 있는 패턴을 분석해주세요.
`;

    const model = this.genAI.getGenerativeModel({ model: 'gemini-pro' });
    const result = await model.generateContent(prompt);
    
    return this.parsePatternResponse(result.response.text());
  }
}
```

### **4단계: 피드백 루프 시스템**

#### **교사 피드백 인터페이스**
```jsx
// TeacherFeedbackInterface.jsx
const TeacherFeedbackInterface = ({ studentResponse, aiAnalysis }) => {
  const [feedback, setFeedback] = useState({
    seeScore: aiAnalysis.seeAnalysis.score,
    thinkScore: aiAnalysis.thinkAnalysis.score,
    wonderScore: aiAnalysis.wonderAnalysis.score,
    aiQuality: 3, // AI 분석의 품질 평가
    improvements: '',
    additionalNotes: ''
  });

  const handleSubmitFeedback = async () => {
    // 피드백 데이터 수집
    await collectTeacherFeedback(studentResponse.id, feedback, aiAnalysis);
    
    // 즉시 학습 데이터로 활용
    await updateAnalysisModel(feedback);
  };

  return (
    <div className="bg-white rounded-lg shadow-lg p-6">
      <h3 className="text-lg font-bold mb-4">🤖 AI 분석 검토</h3>
      
      {/* AI 분석 결과 표시 */}
      <div className="bg-blue-50 p-4 rounded-lg mb-6">
        <h4 className="font-semibold mb-2">AI 분석 결과</h4>
        <div className="space-y-2">
          <div>SEE: {aiAnalysis.seeAnalysis.score}점 - {aiAnalysis.seeAnalysis.feedback}</div>
          <div>THINK: {aiAnalysis.thinkAnalysis.score}점 - {aiAnalysis.thinkAnalysis.feedback}</div>
          <div>WONDER: {aiAnalysis.wonderAnalysis.score}점 - {aiAnalysis.wonderAnalysis.feedback}</div>
        </div>
      </div>

      {/* 교사 수정 */}
      <div className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-2">
            AI 분석 품질 평가 (1-5점)
          </label>
          <select 
            value={feedback.aiQuality}
            onChange={(e) => setFeedback({...feedback, aiQuality: parseInt(e.target.value)})}
            className="w-full p-2 border rounded-lg"
          >
            <option value={1}>1점 - 매우 부정확</option>
            <option value={2}>2점 - 부정확</option>
            <option value={3}>3점 - 보통</option>
            <option value={4}>4점 - 정확</option>
            <option value={5}>5점 - 매우 정확</option>
          </select>
        </div>

        {/* 점수 조정 */}
        <div className="grid grid-cols-3 gap-4">
          <div>
            <label className="block text-sm font-medium mb-2">SEE 점수 조정</label>
            <input 
              type="number" 
              min="1" 
              max="5" 
              value={feedback.seeScore}
              onChange={(e) => setFeedback({...feedback, seeScore: parseInt(e.target.value)})}
              className="w-full p-2 border rounded-lg"
            />
          </div>
          <div>
            <label className="block text-sm font-medium mb-2">THINK 점수 조정</label>
            <input 
              type="number" 
              min="1" 
              max="5" 
              value={feedback.thinkScore}
              onChange={(e) => setFeedback({...feedback, thinkScore: parseInt(e.target.value)})}
              className="w-full p-2 border rounded-lg"
            />
          </div>
          <div>
            <label className="block text-sm font-medium mb-2">WONDER 점수 조정</label>
            <input 
              type="number" 
              min="1" 
              max="5" 
              value={feedback.wonderScore}
              onChange={(e) => setFeedback({...feedback, wonderScore: parseInt(e.target.value)})}
              className="w-full p-2 border rounded-lg"
            />
          </div>
        </div>

        <div>
          <label className="block text-sm font-medium mb-2">
            AI 분석 개선 제안
          </label>
          <textarea 
            value={feedback.improvements}
            onChange={(e) => setFeedback({...feedback, improvements: e.target.value})}
            placeholder="AI가 놓친 부분이나 개선할 점을 적어주세요..."
            className="w-full p-3 border rounded-lg h-24"
          />
        </div>

        <button 
          onClick={handleSubmitFeedback}
          className="w-full bg-green-600 text-white p-3 rounded-lg font-medium"
        >
          피드백 제출 및 AI 학습에 기여하기
        </button>
      </div>
    </div>
  );
};
```

### **5단계: 성능 모니터링 대시보드**

#### **학습 진행 상황 추적**
```jsx
// LearningDashboard.jsx
const LearningDashboard = () => {
  const [metrics, setMetrics] = useState(null);

  useEffect(() => {
    fetchLearningMetrics();
  }, []);

  const fetchLearningMetrics = async () => {
    const data = await supabase
      .from('learning_metrics')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(30);
    
    setMetrics(data);
  };

  return (
    <div className="p-6">
      <h2 className="text-2xl font-bold mb-6">🧠 AI 학습 현황</h2>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
        <div className="bg-white p-6 rounded-lg shadow">
          <h3 className="font-semibold text-gray-700">수집된 데이터</h3>
          <p className="text-3xl font-bold text-blue-600">{metrics?.totalResponses || 0}</p>
          <p className="text-sm text-gray-500">학생 응답 수</p>
        </div>
        
        <div className="bg-white p-6 rounded-lg shadow">
          <h3 className="font-semibold text-gray-700">교사 피드백</h3>
          <p className="text-3xl font-bold text-green-600">{metrics?.teacherFeedbacks || 0}</p>
          <p className="text-sm text-gray-500">검증된 분석</p>
        </div>
        
        <div className="bg-white p-6 rounded-lg shadow">
          <h3 className="font-semibold text-gray-700">AI 정확도</h3>
          <p className="text-3xl font-bold text-purple-600">{metrics?.accuracy || 0}%</p>
          <p className="text-sm text-gray-500">교사 평가 대비</p>
        </div>
      </div>

      {/* 학습 곡선 그래프 */}
      <div className="bg-white p-6 rounded-lg shadow">
        <h3 className="font-semibold mb-4">AI 성능 향상 추이</h3>
        <div className="h-64">
          {/* Chart.js 또는 다른 차트 라이브러리 */}
        </div>
      </div>
    </div>
  );
};
```

## 🎯 **선순환 구조의 장점**

### **1. 실용성**
- 실제 사용 데이터 기반 학습
- 한국 교육 환경에 최적화
- 교사들의 실제 피드백 반영

### **2. 지속적 개선**
- 사용할수록 더 정확해짐
- 새로운 패턴 자동 발견
- 실시간 품질 향상

### **3. 효율성**
- 초기 투자 비용 최소화
- 점진적 품질 향상
- 사용자 참여 유도

## 🚀 **구현 로드맵**

### **Phase 1: 기본 시스템 (1-2주)**
```
✅ 최소 지식 베이스 구축
✅ 기본 AI 분석 기능
✅ 교사 피드백 수집 시스템
```

### **Phase 2: 학습 시스템 (2-3주)**
```
🔄 데이터 수집 자동화
🔄 패턴 분석 시스템
🔄 지식 베이스 자동 업데이트
```

### **Phase 3: 최적화 (지속적)**
```
📈 성능 모니터링 대시보드
📈 A/B 테스트 시스템
📈 고급 분석 기능
```

이런 방식으로 하시면 **처음에는 간단하게 시작해서 점점 더 똑똑해지는 AI 시스템**을 만들 수 있습니다! 

특히 교사들이 직접 사용하면서 피드백을 주는 과정에서 **실제 교육 현장에 최적화된 분석 시스템**으로 발전할 수 있어요. 

이 접근 방식이 훨씬 현실적이고 지속 가능할 것 같습니다! 🎯

```javascript
// initialKnowledgeBase.js
const seedKnowledge = {
  seeThinkWonder: {
    basic: {
      see: {
        purpose: "구체적이고 객관적인 관찰",
        goodIndicators: ["구체적 묘사", "객관적 표현", "다양한 요소"],
        badIndicators: ["감정적 표현", "너무 단순", "주관적 해석"]
      },
      think: {
        purpose: "관찰을 바탕으로 한 해석적 사고",
        goodIndicators: ["논리적 연결", "창의적 해석", "깊이 있는 사고"],
        badIndicators: ["관찰과 무관", "단순한 반복", "근거 부족"]
      },
      wonder: {
        purpose: "탐구 가능한 질문 생성",
        goodIndicators: ["구체적 질문", "탐구 가능", "확장성"],
        badIndicators: ["단순한 정보", "주관적 판단", "탐구 불가"]
      }
    }
  }
};
```

```javascript
// dataCollector.js
class LearningDataCollector {
  constructor() {
    this.supabase = supabase;
  }

  // 교사 피드백 수집
  async collectTeacherFeedback(responseId, teacherFeedback, aiAnalysis) {
    const learningData = {
      student_response: await this.getStudentResponse(responseId),
      ai_analysis: aiAnalysis,
      teacher_feedback: teacherFeedback,
      teacher_agreement: {
        see_score_diff: Math.abs(teacherFeedback.seeScore - aiAnalysis.seeAnalysis.score),
        think_score_diff: Math.abs(teacherFeedback.thinkScore - aiAnalysis.thinkAnalysis.score),
        wonder_score_diff: Math.abs(teacherFeedback.wonderScore - aiAnalysis.wonderAnalysis.score)
      },
      feedback_quality: teacherFeedback.quality, // 교사가 AI 분석의 품질 평가
      timestamp: new Date().toISOString()
    };

    // 학습 데이터 저장
    await this.supabase
      .from('learning_data')
      .insert(learningData);

    return learningData;
  }

  // 우수 사례 자동 식별
  async identifyExcellentCases() {
    const { data: cases } = await this.supabase
      .from('learning_data')
      .select('*')
      .gte('teacher_feedback.overall_score', 4)
      .lte('teacher_agreement.see_score_diff', 1)
      .lte('teacher_agreement.think_score_diff', 1)
      .lte('teacher_agreement.wonder_score_diff', 1);

    return cases;
  }

  // 개선 필요 패턴 분석
  async analyzeImprovementPatterns() {
    const { data: patterns } = await this.supabase
      .from('learning_data')
      .select('*')
      .or('teacher_agreement.see_score_diff.gte.2,teacher_agreement.think_score_diff.gte.2,teacher_agreement.wonder_score_diff.gte.2');

    return this.categorizePatterns(patterns);
  }
}
```

```javascript
// knowledgeEvolution.js
class KnowledgeEvolution {
  constructor() {
    this.vectorStore = new VectorStore();
    this.dataCollector = new LearningDataCollector();
  }

  // 주기적 지식 베이스 업데이트 (예: 매주)
  async evolveKnowledgeBase() {
    console.log('🔄 지식 베이스 진화 시작...');

    // 1. 새로운 우수 사례 수집
    const excellentCases = await this.dataCollector.identifyExcellentCases();
    
    // 2. 개선 패턴 분석
    const improvementPatterns = await this.dataCollector.analyzeImprovementPatterns();
    
    // 3. 새로운 지식 생성
    const newKnowledge = await this.generateNewKnowledge(excellentCases, improvementPatterns);
    
    // 4. 벡터 DB 업데이트
    await this.updateVectorStore(newKnowledge);
    
    console.log('✅ 지식 베이스 진화 완료!');
  }

  async generateNewKnowledge(excellentCases, improvementPatterns) {
    const newKnowledge = [];

    // 우수 사례에서 패턴 추출
    for (const case_ of excellentCases) {
      const pattern = await this.extractPattern(case_);
      newKnowledge.push({
        type: 'excellent_pattern',
        stage: pattern.stage,
        content: pattern.description,
        examples: [case_.student_response],
        confidence: this.calculateConfidence(case_)
      });
    }

    // 개선 패턴에서 가이드라인 생성
    for (const pattern of improvementPatterns) {
      newKnowledge.push({
        type: 'improvement_guide',
        stage: pattern.stage,
        content: pattern.guidance,
        commonMistakes: pattern.mistakes,
        confidence: pattern.frequency
      });
    }

    return newKnowledge;
  }

  async extractPattern(case_) {
    // Gemini API로 패턴 추출
    const prompt = `
다음 우수 사례에서 패턴을 추출해주세요:

학생 응답: ${JSON.stringify(case_.student_response)}
교사 평가: ${JSON.stringify(case_.teacher_feedback)}

이 사례가 우수한 이유와 다른 학생들이 참고할 수 있는 패턴을 분석해주세요.
`;

    const model = this.genAI.getGenerativeModel({ model: 'gemini-pro' });
    const result = await model.generateContent(prompt);
    
    return this.parsePatternResponse(result.response.text());
  }
}
```

```javascriptreact
// TeacherFeedbackInterface.jsx
const TeacherFeedbackInterface = ({ studentResponse, aiAnalysis }) => {
  const [feedback, setFeedback] = useState({
    seeScore: aiAnalysis.seeAnalysis.score,
    thinkScore: aiAnalysis.thinkAnalysis.score,
    wonderScore: aiAnalysis.wonderAnalysis.score,
    aiQuality: 3, // AI 분석의 품질 평가
    improvements: '',
    additionalNotes: ''
  });

  const handleSubmitFeedback = async () => {
    // 피드백 데이터 수집
    await collectTeacherFeedback(studentResponse.id, feedback, aiAnalysis);
    
    // 즉시 학습 데이터로 활용
    await updateAnalysisModel(feedback);
  };

  return (
    <div className="bg-white rounded-lg shadow-lg p-6">
      <h3 className="text-lg font-bold mb-4">🤖 AI 분석 검토</h3>
      
      {/* AI 분석 결과 표시 */}
      <div className="bg-blue-50 p-4 rounded-lg mb-6">
        <h4 className="font-semibold mb-2">AI 분석 결과</h4>
        <div className="space-y-2">
          <div>SEE: {aiAnalysis.seeAnalysis.score}점 - {aiAnalysis.seeAnalysis.feedback}</div>
          <div>THINK: {aiAnalysis.thinkAnalysis.score}점 - {aiAnalysis.thinkAnalysis.feedback}</div>
          <div>WONDER: {aiAnalysis.wonderAnalysis.score}점 - {aiAnalysis.wonderAnalysis.feedback}</div>
        </div>
      </div>

      {/* 교사 수정 */}
      <div className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-2">
            AI 분석 품질 평가 (1-5점)
          </label>
          <select 
            value={feedback.aiQuality}
            onChange={(e) => setFeedback({...feedback, aiQuality: parseInt(e.target.value)})}
            className="w-full p-2 border rounded-lg"
          >
            <option value={1}>1점 - 매우 부정확</option>
            <option value={2}>2점 - 부정확</option>
            <option value={3}>3점 - 보통</option>
            <option value={4}>4점 - 정확</option>
            <option value={5}>5점 - 매우 정확</option>
          </select>
        </div>

        {/* 점수 조정 */}
        <div className="grid grid-cols-3 gap-4">
          <div>
            <label className="block text-sm font-medium mb-2">SEE 점수 조정</label>
            <input 
              type="number" 
              min="1" 
              max="5" 
              value={feedback.seeScore}
              onChange={(e) => setFeedback({...feedback, seeScore: parseInt(e.target.value)})}
              className="w-full p-2 border rounded-lg"
            />
          </div>
          <div>
            <label className="block text-sm font-medium mb-2">THINK 점수 조정</label>
            <input 
              type="number" 
              min="1" 
              max="5" 
              value={feedback.thinkScore}
              onChange={(e) => setFeedback({...feedback, thinkScore: parseInt(e.target.value)})}
              className="w-full p-2 border rounded-lg"
            />
          </div>
          <div>
            <label className="block text-sm font-medium mb-2">WONDER 점수 조정</label>
            <input 
              type="number" 
              min="1" 
              max="5" 
              value={feedback.wonderScore}
              onChange={(e) => setFeedback({...feedback, wonderScore: parseInt(e.target.value)})}
              className="w-full p-2 border rounded-lg"
            />
          </div>
        </div>

        <div>
          <label className="block text-sm font-medium mb-2">
            AI 분석 개선 제안
          </label>
          <textarea 
            value={feedback.improvements}
            onChange={(e) => setFeedback({...feedback, improvements: e.target.value})}
            placeholder="AI가 놓친 부분이나 개선할 점을 적어주세요..."
            className="w-full p-3 border rounded-lg h-24"
          />
        </div>

        <button 
          onClick={handleSubmitFeedback}
          className="w-full bg-green-600 text-white p-3 rounded-lg font-medium"
        >
          피드백 제출 및 AI 학습에 기여하기
        </button>
      </div>
    </div>
  );
};
```

```javascriptreact
// LearningDashboard.jsx
const LearningDashboard = () => {
  const [metrics, setMetrics] = useState(null);

  useEffect(() => {
    fetchLearningMetrics();
  }, []);

  const fetchLearningMetrics = async () => {
    const data = await supabase
      .from('learning_metrics')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(30);
    
    setMetrics(data);
  };

  return (
    <div className="p-6">
      <h2 className="text-2xl font-bold mb-6">🧠 AI 학습 현황</h2>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
        <div className="bg-white p-6 rounded-lg shadow">
          <h3 className="font-semibold text-gray-700">수집된 데이터</h3>
          <p className="text-3xl font-bold text-blue-600">{metrics?.totalResponses || 0}</p>
          <p className="text-sm text-gray-500">학생 응답 수</p>
        </div>
        
        <div className="bg-white p-6 rounded-lg shadow">
          <h3 className="font-semibold text-gray-700">교사 피드백</h3>
          <p className="text-3xl font-bold text-green-600">{metrics?.teacherFeedbacks || 0}</p>
          <p className="text-sm text-gray-500">검증된 분석</p>
        </div>
        
        <div className="bg-white p-6 rounded-lg shadow">
          <h3 className="font-semibold text-gray-700">AI 정확도</h3>
          <p className="text-3xl font-bold text-purple-600">{metrics?.accuracy || 0}%</p>
          <p className="text-sm text-gray-500">교사 평가 대비</p>
        </div>
      </div>

      {/* 학습 곡선 그래프 */}
      <div className="bg-white p-6 rounded-lg shadow">
        <h3 className="font-semibold mb-4">AI 성능 향상 추이</h3>
        <div className="h-64">
          {/* Chart.js 또는 다른 차트 라이브러리 */}
        </div>
      </div>
    </div>
  );
};
```

```plaintext
✅ 최소 지식 베이스 구축
✅ 기본 AI 분석 기능
✅ 교사 피드백 수집 시스템
```

```plaintext
🔄 데이터 수집 자동화
🔄 패턴 분석 시스템
🔄 지식 베이스 자동 업데이트
```

```plaintext
📈 성능 모니터링 대시보드
📈 A/B 테스트 시스템
📈 고급 분석 기능
```

---